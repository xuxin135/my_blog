{"ast":null,"code":"import \"core-js/modules/es.array.includes.js\";\nimport { isNumber, $, isString } from '../utils/util';\nimport throwError from '../utils/error';\nimport { defineComponent, ref, reactive, computed, watch, onMounted, onBeforeUnmount, h, withModifiers, getCurrentInstance, onUpdated, resolveDynamicComponent, nextTick } from 'vue';\nimport memo from 'lodash/memoize';\nimport isServer from '../utils/isServer';\nimport { cAF, rAF } from '../utils/raf';\nimport { on, off } from '../utils/dom';\nimport getScrollBarWidth from '../utils/scrollbar-width';\n/**\r\n * Make a map and return a function for checking if a key\r\n * is in that map.\r\n * IMPORTANT: all calls of this function must be prefixed with\r\n * \\/\\*#\\_\\_PURE\\_\\_\\*\\/\r\n * So that rollup can tree-shake them if necessary.\r\n */\n\nconst EMPTY_OBJ = process.env.NODE_ENV !== 'production' ? Object.freeze({}) : {};\nconst EMPTY_ARR = process.env.NODE_ENV !== 'production' ? Object.freeze([]) : [];\n\nconst NOOP = () => {};\n\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\n\nconst hasOwn = (val, key) => hasOwnProperty.call(val, key);\n\nconst isFunction = val => typeof val === 'function';\n\nconst isObject = val => val !== null && typeof val === 'object';\n\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\n\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\n\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {})) if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n\n  if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)) {\n    if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  }\n  return a;\n};\n\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\n\nconst DEFAULT_DYNAMIC_LIST_ITEM_SIZE = 50;\nconst ITEM_RENDER_EVT = \"item-rendered\";\nconst SCROLL_EVT = \"scroll\";\nconst FORWARD = \"forward\";\nconst BACKWARD = \"backward\";\nconst AUTO_ALIGNMENT = \"auto\";\nconst SMART_ALIGNMENT = \"smart\";\nconst START_ALIGNMENT = \"start\";\nconst CENTERED_ALIGNMENT = \"center\";\nconst END_ALIGNMENT = \"end\";\nconst HORIZONTAL = \"horizontal\";\nconst VERTICAL = \"vertical\";\nconst LTR = \"ltr\";\nconst RTL = \"rtl\";\nconst RTL_OFFSET_NAG = \"negative\";\nconst RTL_OFFSET_POS_ASC = \"positive-ascending\";\nconst RTL_OFFSET_POS_DESC = \"positive-descending\";\nconst DefaultListProps = {\n  cache: {\n    type: Number,\n    default: 2\n  },\n  className: {\n    type: String,\n    default: \"\"\n  },\n  containerElement: {\n    type: [String, Object],\n    default: \"div\"\n  },\n  data: {\n    type: [Array],\n    default: () => []\n  },\n  direction: {\n    type: String,\n    default: \"ltr\",\n    validator: val => {\n      return val === LTR || val === RTL;\n    }\n  },\n  estimatedItemSize: {\n    type: [Number]\n  },\n  height: {\n    type: [String, Number],\n    required: true\n  },\n  layout: {\n    type: String,\n    default: VERTICAL\n  },\n  initScrollOffset: {\n    type: Number,\n    default: 0\n  },\n  innerElement: {\n    type: [String, Object],\n    default: \"div\"\n  },\n  total: {\n    type: Number,\n    required: true\n  },\n  itemSize: {\n    type: [Number, Function],\n    required: true\n  },\n  style: {\n    type: [Object, String, Array],\n    default: () => ({})\n  },\n  useIsScrolling: {\n    type: Boolean,\n    default: false\n  },\n  width: {\n    type: [Number, String],\n    required: true\n  }\n};\nconst DefaultGridProps = {\n  className: DefaultListProps.className,\n  columnCache: DefaultListProps.cache,\n  columnWidth: DefaultListProps.itemSize,\n  containerElement: DefaultListProps.containerElement,\n  data: DefaultListProps.data,\n  direction: DefaultListProps.direction,\n  estimatedColumnWidth: DefaultListProps.estimatedItemSize,\n  estimatedRowHeight: DefaultListProps.estimatedItemSize,\n  height: __spreadProps(__spreadValues({}, DefaultListProps.height), {\n    validator: val => isNumber(val)\n  }),\n  initScrollLeft: DefaultListProps.initScrollOffset,\n  initScrollTop: DefaultListProps.initScrollOffset,\n  innerElement: DefaultListProps.innerElement,\n  rowCache: DefaultListProps.cache,\n  rowHeight: DefaultListProps.itemSize,\n  style: DefaultListProps.style,\n  useIsScrolling: DefaultListProps.useIsScrolling,\n  width: __spreadProps(__spreadValues({}, DefaultListProps.width), {\n    validator: val => {\n      return isNumber(val);\n    }\n  }),\n  totalColumn: DefaultListProps.total,\n  totalRow: DefaultListProps.total\n};\nconst DefaultScrollBarProps = {\n  layout: DefaultListProps.layout,\n  total: Number,\n  ratio: Number,\n  clientSize: Number,\n  scrollFrom: Number,\n  visible: Boolean\n};\nconst ScrollbarDirKey = {\n  [HORIZONTAL]: \"left\",\n  [VERTICAL]: \"top\"\n};\nconst SCROLLBAR_MIN_SIZE = 20;\n\nconst getScrollDir = (prev, cur) => prev < cur ? FORWARD : BACKWARD;\n\nconst isHorizontal = dir => dir === LTR || dir === RTL || dir === HORIZONTAL;\n\nconst isRTL = dir => dir === RTL;\n\nlet cachedRTLResult = null;\n\nfunction getRTLOffsetType(recalculate = false) {\n  if (cachedRTLResult === null || recalculate) {\n    const outerDiv = document.createElement(\"div\");\n    const outerStyle = outerDiv.style;\n    outerStyle.width = \"50px\";\n    outerStyle.height = \"50px\";\n    outerStyle.overflow = \"scroll\";\n    outerStyle.direction = \"rtl\";\n    const innerDiv = document.createElement(\"div\");\n    const innerStyle = innerDiv.style;\n    innerStyle.width = \"100px\";\n    innerStyle.height = \"100px\";\n    outerDiv.appendChild(innerDiv);\n    document.body.appendChild(outerDiv);\n\n    if (outerDiv.scrollLeft > 0) {\n      cachedRTLResult = RTL_OFFSET_POS_DESC;\n    } else {\n      outerDiv.scrollLeft = 1;\n\n      if (outerDiv.scrollLeft === 0) {\n        cachedRTLResult = RTL_OFFSET_NAG;\n      } else {\n        cachedRTLResult = RTL_OFFSET_POS_ASC;\n      }\n    }\n\n    document.body.removeChild(outerDiv);\n    return cachedRTLResult;\n  }\n\n  return cachedRTLResult;\n}\n\nfunction renderThumbStyle({\n  move,\n  size,\n  bar\n}, layout) {\n  const style = {};\n  const translate = `translate${bar.axis}(${move}px)`;\n  style[bar.size] = size;\n  style.transform = translate;\n  style.msTransform = translate;\n  style.webkitTransform = translate;\n\n  if (layout === \"horizontal\") {\n    style.height = \"100%\";\n  } else {\n    style.width = \"100%\";\n  }\n\n  return style;\n}\n\nconst isFF = typeof navigator !== \"undefined\" && isObject(navigator) && /Firefox/i.test(navigator.userAgent);\nconst LayoutKeys = {\n  [HORIZONTAL]: \"deltaX\",\n  [VERTICAL]: \"deltaY\"\n};\n\nconst useWheel = ({\n  atEndEdge,\n  atStartEdge,\n  layout\n}, onWheelDelta) => {\n  let frameHandle = null;\n  let offset = 0;\n\n  const hasReachedEdge = offset2 => {\n    const edgeReached = offset2 < 0 && atStartEdge.value || offset2 > 0 && atEndEdge.value;\n    return edgeReached;\n  };\n\n  const onWheel = e => {\n    cAF(frameHandle);\n    const newOffset = e[LayoutKeys[layout.value]];\n    if (hasReachedEdge(offset) && hasReachedEdge(offset + newOffset)) return;\n    offset += newOffset;\n\n    if (!isFF) {\n      e.preventDefault();\n    }\n\n    frameHandle = rAF(() => {\n      onWheelDelta(offset);\n      offset = 0;\n    });\n  };\n\n  return {\n    hasReachedEdge,\n    onWheel\n  };\n};\n\nconst BAR_MAP = {\n  vertical: {\n    offset: \"offsetHeight\",\n    scroll: \"scrollTop\",\n    scrollSize: \"scrollHeight\",\n    size: \"height\",\n    key: \"vertical\",\n    axis: \"Y\",\n    client: \"clientY\",\n    direction: \"top\"\n  },\n  horizontal: {\n    offset: \"offsetWidth\",\n    scroll: \"scrollLeft\",\n    scrollSize: \"scrollWidth\",\n    size: \"width\",\n    key: \"horizontal\",\n    axis: \"X\",\n    client: \"clientX\",\n    direction: \"left\"\n  }\n};\nconst ScrollBar = defineComponent({\n  name: \"ElVirtualScrollBar\",\n  props: DefaultScrollBarProps,\n  emits: [\"scroll\", \"start-move\", \"stop-move\"],\n\n  setup(props, {\n    emit\n  }) {\n    const trackRef = ref(null);\n    const thumbRef = ref(null);\n    let frameHandle = null;\n    let onselectstartStore = null;\n    const state = reactive({\n      isDragging: false,\n      traveled: 0\n    });\n    const bar = computed(() => BAR_MAP[props.layout]);\n    const trackStyle = computed(() => ({\n      display: props.visible ? null : \"none\",\n      position: \"absolute\",\n      width: HORIZONTAL === props.layout ? \"100%\" : \"6px\",\n      height: HORIZONTAL === props.layout ? \"6px\" : \"100%\",\n      [ScrollbarDirKey[props.layout]]: \"2px\",\n      right: \"2px\",\n      bottom: \"2px\",\n      borderRadius: \"4px\"\n    }));\n    const thumbSize = computed(() => {\n      if (props.ratio >= 100) {\n        return Number.POSITIVE_INFINITY;\n      }\n\n      if (props.ratio >= 50) {\n        return props.ratio * props.clientSize / 100;\n      }\n\n      const SCROLLBAR_MAX_SIZE = props.clientSize / 3;\n      return Math.floor(Math.min(Math.max(props.ratio * props.clientSize, SCROLLBAR_MIN_SIZE), SCROLLBAR_MAX_SIZE));\n    });\n    const thumbStyle = computed(() => {\n      if (!Number.isFinite(thumbSize.value)) {\n        return {\n          display: \"none\"\n        };\n      }\n\n      const thumb = `${thumbSize.value}px`;\n      const style = renderThumbStyle({\n        bar: bar.value,\n        size: thumb,\n        move: state.traveled\n      }, props.layout);\n      return style;\n    });\n    const totalSteps = computed(() => Math.floor(props.clientSize - thumbSize.value - 4));\n\n    const attachEvents = () => {\n      on(window, \"mousemove\", onMouseMove);\n      on(window, \"mouseup\", onMouseUp);\n      const thumbEl = thumbRef.value;\n      onselectstartStore = document.onselectstart;\n\n      document.onselectstart = () => false;\n\n      on(thumbEl, \"touchmove\", onMouseMove);\n      on(thumbEl, \"touchend\", onMouseUp);\n    };\n\n    const detachEvents = () => {\n      off(window, \"mousemove\", onMouseMove);\n      off(window, \"mouseup\", onMouseUp);\n      document.onselectstart = onselectstartStore;\n      onselectstartStore = null;\n      const thumbEl = thumbRef.value;\n      off(thumbEl, \"touchmove\", onMouseMove);\n      off(thumbEl, \"touchend\", onMouseUp);\n    };\n\n    const onThumbMouseDown = e => {\n      e.stopImmediatePropagation();\n\n      if (e.ctrlKey || [1, 2].includes(e.button)) {\n        return;\n      }\n\n      state.isDragging = true;\n      state[bar.value.axis] = e.currentTarget[bar.value.offset] - (e[bar.value.client] - e.currentTarget.getBoundingClientRect()[bar.value.direction]);\n      emit(\"start-move\");\n      attachEvents();\n    };\n\n    const onMouseUp = () => {\n      state.isDragging = false;\n      state[bar.value.axis] = 0;\n      emit(\"stop-move\");\n      detachEvents();\n    };\n\n    const onMouseMove = e => {\n      const {\n        isDragging\n      } = state;\n      if (!isDragging) return;\n      const prevPage = state[bar.value.axis];\n      if (!prevPage) return;\n      cAF(frameHandle);\n      const offset = (trackRef.value.getBoundingClientRect()[bar.value.direction] - e[bar.value.client]) * -1;\n      const thumbClickPosition = thumbRef.value[bar.value.offset] - prevPage;\n      const distance = offset - thumbClickPosition;\n      frameHandle = rAF(() => {\n        state.traveled = Math.max(2, Math.min(distance, totalSteps.value));\n        emit(\"scroll\", distance, totalSteps.value);\n      });\n    };\n\n    const onScrollbarTouchStart = e => e.preventDefault();\n\n    watch(() => props.scrollFrom, v => {\n      if (state.isDragging) return;\n      state.traveled = Math.ceil(v * props.clientSize / (props.clientSize / totalSteps.value));\n    });\n    onMounted(() => {\n      if (isServer) return;\n      on(trackRef.value, \"touchstart\", onScrollbarTouchStart);\n      on(thumbRef.value, \"touchstart\", onThumbMouseDown);\n    });\n    onBeforeUnmount(() => {\n      off(trackRef.value, \"touchstart\", onScrollbarTouchStart);\n      detachEvents();\n    });\n    return () => {\n      return h(\"div\", {\n        role: \"presentation\",\n        ref: trackRef,\n        class: \"el-virtual-scrollbar\",\n        style: trackStyle.value,\n        onMousedown: withModifiers(NOOP, [\"stop\", \"prevent\"])\n      }, h(\"div\", {\n        ref: thumbRef,\n        class: \"el-scrollbar__thumb\",\n        style: thumbStyle.value,\n        onMousedown: onThumbMouseDown\n      }, null));\n    };\n  }\n\n});\nvar __defProp$1 = Object.defineProperty;\nvar __defProps$1 = Object.defineProperties;\nvar __getOwnPropDescs$1 = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols$1 = Object.getOwnPropertySymbols;\nvar __hasOwnProp$1 = Object.prototype.hasOwnProperty;\nvar __propIsEnum$1 = Object.prototype.propertyIsEnumerable;\n\nvar __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\n\nvar __spreadValues$1 = (a, b) => {\n  for (var prop in b || (b = {})) if (__hasOwnProp$1.call(b, prop)) __defNormalProp$1(a, prop, b[prop]);\n\n  if (__getOwnPropSymbols$1) for (var prop of __getOwnPropSymbols$1(b)) {\n    if (__propIsEnum$1.call(b, prop)) __defNormalProp$1(a, prop, b[prop]);\n  }\n  return a;\n};\n\nvar __spreadProps$1 = (a, b) => __defProps$1(a, __getOwnPropDescs$1(b));\n\nconst createList = ({\n  name,\n  getOffset,\n  getItemSize,\n  getItemOffset,\n  getEstimatedTotalSize,\n  getStartIndexForOffset,\n  getStopIndexForStartIndex,\n  initCache,\n  clearCache,\n  validateProps\n}) => {\n  return defineComponent({\n    name: name != null ? name : \"ElVirtualList\",\n    props: DefaultListProps,\n    emits: [ITEM_RENDER_EVT, SCROLL_EVT],\n\n    setup(props, {\n      emit,\n      expose\n    }) {\n      validateProps(props);\n      const instance = getCurrentInstance();\n      const dynamicSizeCache = ref(initCache(props, instance));\n      const windowRef = ref(null);\n      const innerRef = ref(null);\n      const scrollbarRef = ref(null);\n      const states = ref({\n        isScrolling: false,\n        scrollDir: \"forward\",\n        scrollOffset: isNumber(props.initScrollOffset) ? props.initScrollOffset : 0,\n        updateRequested: false,\n        isScrollbarDragging: false\n      });\n      const itemsToRender = computed(() => {\n        const {\n          total,\n          cache\n        } = props;\n        const {\n          isScrolling,\n          scrollDir,\n          scrollOffset\n        } = $(states);\n\n        if (total === 0) {\n          return [0, 0, 0, 0];\n        }\n\n        const startIndex = getStartIndexForOffset(props, scrollOffset, $(dynamicSizeCache));\n        const stopIndex = getStopIndexForStartIndex(props, startIndex, scrollOffset, $(dynamicSizeCache));\n        const cacheBackward = !isScrolling || scrollDir === BACKWARD ? Math.max(1, cache) : 1;\n        const cacheForward = !isScrolling || scrollDir === FORWARD ? Math.max(1, cache) : 1;\n        return [Math.max(0, startIndex - cacheBackward), Math.max(0, Math.min(total - 1, stopIndex + cacheForward)), startIndex, stopIndex];\n      });\n      const estimatedTotalSize = computed(() => getEstimatedTotalSize(props, $(dynamicSizeCache)));\n\n      const _isHorizontal = computed(() => isHorizontal(props.layout));\n\n      const windowStyle = computed(() => [{\n        position: \"relative\",\n        overflow: \"hidden\",\n        WebkitOverflowScrolling: \"touch\",\n        willChange: \"transform\"\n      }, __spreadValues$1({\n        direction: props.direction,\n        height: isNumber(props.height) ? `${props.height}px` : props.height,\n        width: isNumber(props.width) ? `${props.width}px` : props.width\n      }, props.style)]);\n      const innerStyle = computed(() => {\n        const size = $(estimatedTotalSize);\n        const horizontal = $(_isHorizontal);\n        return {\n          height: horizontal ? \"100%\" : `${size}px`,\n          pointerEvents: $(states).isScrolling ? \"none\" : void 0,\n          width: horizontal ? `${size}px` : \"100%\"\n        };\n      });\n      const clientSize = computed(() => _isHorizontal.value ? props.width : props.height);\n      const {\n        onWheel\n      } = useWheel({\n        atStartEdge: computed(() => states.value.scrollOffset <= 0),\n        atEndEdge: computed(() => states.value.scrollOffset >= estimatedTotalSize.value),\n        layout: computed(() => props.layout)\n      }, offset => {\n        var _a, _b;\n\n        (_b = (_a = scrollbarRef.value).onMouseUp) == null ? void 0 : _b.call(_a);\n        scrollTo(Math.min(states.value.scrollOffset + offset, estimatedTotalSize.value - clientSize.value));\n      });\n\n      const emitEvents = () => {\n        const {\n          total\n        } = props;\n\n        if (total > 0) {\n          const [cacheStart, cacheEnd, visibleStart, visibleEnd] = $(itemsToRender);\n          emit(ITEM_RENDER_EVT, cacheStart, cacheEnd, visibleStart, visibleEnd);\n        }\n\n        const {\n          scrollDir,\n          scrollOffset,\n          updateRequested\n        } = $(states);\n        emit(SCROLL_EVT, scrollDir, scrollOffset, updateRequested);\n      };\n\n      const scrollVertically = e => {\n        const {\n          clientHeight,\n          scrollHeight,\n          scrollTop\n        } = e.currentTarget;\n\n        const _states = $(states);\n\n        if (_states.scrollOffset === scrollTop) {\n          return;\n        }\n\n        const scrollOffset = Math.max(0, Math.min(scrollTop, scrollHeight - clientHeight));\n        states.value = __spreadProps$1(__spreadValues$1({}, _states), {\n          isScrolling: true,\n          scrollDir: getScrollDir(_states.scrollOffset, scrollOffset),\n          scrollOffset,\n          updateRequested: false\n        });\n        nextTick(resetIsScrolling);\n      };\n\n      const scrollHorizontally = e => {\n        const {\n          clientWidth,\n          scrollLeft,\n          scrollWidth\n        } = e.currentTarget;\n\n        const _states = $(states);\n\n        if (_states.scrollOffset === scrollLeft) {\n          return;\n        }\n\n        const {\n          direction\n        } = props;\n        let scrollOffset = scrollLeft;\n\n        if (direction === RTL) {\n          switch (getRTLOffsetType()) {\n            case RTL_OFFSET_NAG:\n              {\n                scrollOffset = -scrollLeft;\n                break;\n              }\n\n            case RTL_OFFSET_POS_DESC:\n              {\n                scrollOffset = scrollWidth - clientWidth - scrollLeft;\n                break;\n              }\n          }\n        }\n\n        scrollOffset = Math.max(0, Math.min(scrollOffset, scrollWidth - clientWidth));\n        states.value = __spreadProps$1(__spreadValues$1({}, _states), {\n          isScrolling: true,\n          scrollDir: getScrollDir(_states.scrollOffset, scrollOffset),\n          scrollOffset,\n          updateRequested: false\n        });\n        nextTick(resetIsScrolling);\n      };\n\n      const onScroll = e => {\n        $(_isHorizontal) ? scrollHorizontally(e) : scrollVertically(e);\n        emitEvents();\n      };\n\n      const onScrollbarScroll = (distanceToGo, totalSteps) => {\n        const offset = (estimatedTotalSize.value - clientSize.value) / totalSteps * distanceToGo;\n        scrollTo(Math.min(estimatedTotalSize.value - clientSize.value, offset));\n      };\n\n      const getItemStyleCache = memo((_, __, ___) => ({}));\n\n      const scrollTo = offset => {\n        offset = Math.max(offset, 0);\n\n        if (offset === $(states).scrollOffset) {\n          return;\n        }\n\n        states.value = __spreadProps$1(__spreadValues$1({}, $(states)), {\n          scrollOffset: offset,\n          scrollDir: getScrollDir($(states).scrollOffset, offset),\n          updateRequested: true\n        });\n        nextTick(resetIsScrolling);\n      };\n\n      const scrollToItem = (idx, alignment = AUTO_ALIGNMENT) => {\n        const {\n          scrollOffset\n        } = $(states);\n        idx = Math.max(0, Math.min(idx, props.total - 1));\n        scrollTo(getOffset(props, idx, alignment, scrollOffset, $(dynamicSizeCache)));\n      };\n\n      const getItemStyle = idx => {\n        const {\n          direction,\n          itemSize,\n          layout\n        } = props;\n        const itemStyleCache = getItemStyleCache(clearCache && itemSize, clearCache && layout, clearCache && direction);\n        let style;\n\n        if (hasOwn(itemStyleCache, String(idx))) {\n          style = itemStyleCache[idx];\n        } else {\n          const offset = getItemOffset(props, idx, $(dynamicSizeCache));\n          const size = getItemSize(props, idx, $(dynamicSizeCache));\n          const horizontal = $(_isHorizontal);\n          const isRtl = direction === RTL;\n          const offsetHorizontal = horizontal ? offset : 0;\n          itemStyleCache[idx] = style = {\n            position: \"absolute\",\n            left: isRtl ? void 0 : `${offsetHorizontal}px`,\n            right: isRtl ? `${offsetHorizontal}px` : void 0,\n            top: !horizontal ? `${offset}px` : 0,\n            height: !horizontal ? `${size}px` : \"100%\",\n            width: horizontal ? `${size}px` : \"100%\"\n          };\n        }\n\n        return style;\n      };\n\n      const resetIsScrolling = () => {\n        states.value.isScrolling = false;\n        nextTick(() => {\n          getItemStyleCache(-1, null, null);\n        });\n      };\n\n      onMounted(() => {\n        if (isServer) return;\n        const {\n          initScrollOffset\n        } = props;\n        const windowElement = $(windowRef);\n\n        if (isNumber(initScrollOffset) && windowElement !== null) {\n          if ($(_isHorizontal)) {\n            windowElement.scrollLeft = initScrollOffset;\n          } else {\n            windowElement.scrollTop = initScrollOffset;\n          }\n        }\n\n        emitEvents();\n      });\n      onUpdated(() => {\n        const {\n          direction,\n          layout\n        } = props;\n        const {\n          scrollOffset,\n          updateRequested\n        } = $(states);\n\n        if (updateRequested && $(windowRef) !== null) {\n          const windowElement = $(windowRef);\n\n          if (layout === HORIZONTAL) {\n            if (direction === RTL) {\n              switch (getRTLOffsetType()) {\n                case \"negative\":\n                  {\n                    windowElement.scrollLeft = -scrollOffset;\n                    break;\n                  }\n\n                case \"positive-ascending\":\n                  {\n                    windowElement.scrollLeft = scrollOffset;\n                    break;\n                  }\n\n                default:\n                  {\n                    const {\n                      clientWidth,\n                      scrollWidth\n                    } = windowElement;\n                    windowElement.scrollLeft = scrollWidth - clientWidth - scrollOffset;\n                    break;\n                  }\n              }\n            } else {\n              windowElement.scrollLeft = scrollOffset;\n            }\n          } else {\n            windowElement.scrollTop = scrollOffset;\n          }\n        }\n      });\n      const api = {\n        clientSize,\n        estimatedTotalSize,\n        windowStyle,\n        windowRef,\n        innerRef,\n        innerStyle,\n        itemsToRender,\n        scrollbarRef,\n        states,\n        getItemStyle,\n        onScroll,\n        onScrollbarScroll,\n        onWheel,\n        scrollTo,\n        scrollToItem\n      };\n      expose({\n        windowRef,\n        innerRef,\n        getItemStyleCache,\n        scrollTo,\n        scrollToItem,\n        states\n      });\n      return api;\n    },\n\n    render(ctx) {\n      var _a;\n\n      const {\n        $slots,\n        className,\n        clientSize,\n        containerElement,\n        data,\n        getItemStyle,\n        innerElement,\n        itemsToRender,\n        innerStyle,\n        layout,\n        total,\n        onScroll,\n        onScrollbarScroll,\n        onWheel,\n        states,\n        useIsScrolling,\n        windowStyle\n      } = ctx;\n      const [start, end] = itemsToRender;\n      const Container = resolveDynamicComponent(containerElement);\n      const Inner = resolveDynamicComponent(innerElement);\n      const children = [];\n\n      if (total > 0) {\n        for (let i = start; i <= end; i++) {\n          children.push((_a = $slots.default) == null ? void 0 : _a.call($slots, {\n            data,\n            key: i,\n            index: i,\n            isScrolling: useIsScrolling ? states.isScrolling : void 0,\n            style: getItemStyle(i)\n          }));\n        }\n      }\n\n      const InnerNode = [h(Inner, {\n        style: innerStyle,\n        ref: \"innerRef\"\n      }, !isString(Inner) ? {\n        default: () => children\n      } : children)];\n      const scrollbar = h(ScrollBar, {\n        ref: \"scrollbarRef\",\n        clientSize,\n        layout,\n        onScroll: onScrollbarScroll,\n        ratio: clientSize * 100 / this.estimatedTotalSize,\n        scrollFrom: states.scrollOffset / (this.estimatedTotalSize - clientSize),\n        total,\n        visible: true\n      });\n      const listContainer = h(Container, {\n        class: className,\n        style: windowStyle,\n        onScroll,\n        onWheel,\n        ref: \"windowRef\",\n        key: 0\n      }, !isString(Container) ? {\n        default: () => [InnerNode]\n      } : [InnerNode]);\n      return h(\"div\", {\n        key: 0,\n        class: \"el-vl__wrapper\"\n      }, [listContainer, scrollbar]);\n    }\n\n  });\n};\n\nconst FixedSizeList = createList({\n  name: \"ElFixedSizeList\",\n  getItemOffset: ({\n    itemSize\n  }, index) => index * itemSize,\n  getItemSize: ({\n    itemSize\n  }) => itemSize,\n  getEstimatedTotalSize: ({\n    total,\n    itemSize\n  }) => itemSize * total,\n  getOffset: ({\n    height,\n    total,\n    itemSize,\n    layout,\n    width\n  }, index, alignment, scrollOffset) => {\n    const size = isHorizontal(layout) ? width : height;\n\n    if (process.env.ENV !== \"production\" && isString(size)) {\n      throwError(\"[ElVirtualList]\", `\n        You should set\n          width/height\n        to number when your layout is\n          horizontal/vertical\n      `);\n    }\n\n    const lastItemOffset = Math.max(0, total * itemSize - size);\n    const maxOffset = Math.min(lastItemOffset, index * itemSize);\n    const minOffset = Math.max(0, (index + 1) * itemSize - size);\n\n    if (alignment === SMART_ALIGNMENT) {\n      if (scrollOffset >= minOffset - size && scrollOffset <= maxOffset + size) {\n        alignment = AUTO_ALIGNMENT;\n      } else {\n        alignment = CENTERED_ALIGNMENT;\n      }\n    }\n\n    switch (alignment) {\n      case START_ALIGNMENT:\n        {\n          return maxOffset;\n        }\n\n      case END_ALIGNMENT:\n        {\n          return minOffset;\n        }\n\n      case CENTERED_ALIGNMENT:\n        {\n          const middleOffset = Math.round(minOffset + (maxOffset - minOffset) / 2);\n\n          if (middleOffset < Math.ceil(size / 2)) {\n            return 0;\n          } else if (middleOffset > lastItemOffset + Math.floor(size / 2)) {\n            return lastItemOffset;\n          } else {\n            return middleOffset;\n          }\n        }\n\n      case AUTO_ALIGNMENT:\n      default:\n        {\n          if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {\n            return scrollOffset;\n          } else if (scrollOffset < minOffset) {\n            return minOffset;\n          } else {\n            return maxOffset;\n          }\n        }\n    }\n  },\n  getStartIndexForOffset: ({\n    total,\n    itemSize\n  }, offset) => Math.max(0, Math.min(total - 1, Math.floor(offset / itemSize))),\n  getStopIndexForStartIndex: ({\n    height,\n    total,\n    itemSize,\n    layout,\n    width\n  }, startIndex, scrollOffset) => {\n    const offset = startIndex * itemSize;\n    const size = isHorizontal(layout) ? width : height;\n    const numVisibleItems = Math.ceil((size + scrollOffset - offset) / itemSize);\n    return Math.max(0, Math.min(total - 1, startIndex + numVisibleItems - 1));\n  },\n\n  initCache() {\n    return void 0;\n  },\n\n  clearCache: true,\n\n  validateProps() {}\n\n});\nconst SCOPE = \"ElDynamicSizeList\";\n\nconst getItemFromCache = (props, index, listCache) => {\n  const {\n    itemSize\n  } = props;\n  const {\n    items,\n    lastVisitedIndex\n  } = listCache;\n\n  if (index > lastVisitedIndex) {\n    let offset = 0;\n\n    if (lastVisitedIndex >= 0) {\n      const item = items[lastVisitedIndex];\n      offset = item.offset + item.size;\n    }\n\n    for (let i = lastVisitedIndex + 1; i <= index; i++) {\n      const size = itemSize(i);\n      items[i] = {\n        offset,\n        size\n      };\n      offset += size;\n    }\n\n    listCache.lastVisitedIndex = index;\n  }\n\n  return items[index];\n};\n\nconst findItem = (props, listCache, offset) => {\n  const {\n    items,\n    lastVisitedIndex\n  } = listCache;\n  const lastVisitedOffset = lastVisitedIndex > 0 ? items[lastVisitedIndex].offset : 0;\n\n  if (lastVisitedOffset >= offset) {\n    return bs(props, listCache, 0, lastVisitedIndex, offset);\n  }\n\n  return es(props, listCache, Math.max(0, lastVisitedIndex), offset);\n};\n\nconst bs = (props, listCache, low, high, offset) => {\n  while (low <= high) {\n    const mid = low + Math.floor((high - low) / 2);\n    const currentOffset = getItemFromCache(props, mid, listCache).offset;\n\n    if (currentOffset === offset) {\n      return mid;\n    } else if (currentOffset < offset) {\n      low = mid + 1;\n    } else if (currentOffset > offset) {\n      high = mid - 1;\n    }\n  }\n\n  return Math.max(0, low - 1);\n};\n\nconst es = (props, listCache, index, offset) => {\n  const {\n    total\n  } = props;\n  let exponent = 1;\n\n  while (index < total && getItemFromCache(props, index, listCache).offset < offset) {\n    index += exponent;\n    exponent *= 2;\n  }\n\n  return bs(props, listCache, Math.floor(index / 2), Math.min(index, total - 1), offset);\n};\n\nconst getEstimatedTotalSize = ({\n  total\n}, {\n  items,\n  estimatedItemSize,\n  lastVisitedIndex\n}) => {\n  let totalSizeOfMeasuredItems = 0;\n\n  if (lastVisitedIndex >= total) {\n    lastVisitedIndex = total - 1;\n  }\n\n  if (lastVisitedIndex >= 0) {\n    const item = items[lastVisitedIndex];\n    totalSizeOfMeasuredItems = item.offset + item.size;\n  }\n\n  const numUnmeasuredItems = total - lastVisitedIndex - 1;\n  const totalSizeOfUnmeasuredItems = numUnmeasuredItems * estimatedItemSize;\n  return totalSizeOfMeasuredItems + totalSizeOfUnmeasuredItems;\n};\n\nconst DynamicSizeList = createList({\n  name: \"ElDynamicSizeList\",\n  getItemOffset: (props, index, listCache) => getItemFromCache(props, index, listCache).offset,\n  getItemSize: (_, index, {\n    items\n  }) => items[index].size,\n  getEstimatedTotalSize,\n  getOffset: (props, index, alignment, scrollOffset, listCache) => {\n    const {\n      height,\n      layout,\n      width\n    } = props;\n    const size = isHorizontal(layout) ? width : height;\n    const item = getItemFromCache(props, index, listCache);\n    const estimatedTotalSize = getEstimatedTotalSize(props, listCache);\n    const maxOffset = Math.max(0, Math.min(estimatedTotalSize - size, item.offset));\n    const minOffset = Math.max(0, item.offset - size + item.size);\n\n    if (alignment === SMART_ALIGNMENT) {\n      if (scrollOffset >= minOffset - size && scrollOffset <= maxOffset + size) {\n        alignment = AUTO_ALIGNMENT;\n      } else {\n        alignment = CENTERED_ALIGNMENT;\n      }\n    }\n\n    switch (alignment) {\n      case START_ALIGNMENT:\n        {\n          return maxOffset;\n        }\n\n      case END_ALIGNMENT:\n        {\n          return minOffset;\n        }\n\n      case CENTERED_ALIGNMENT:\n        {\n          return Math.round(minOffset + (maxOffset - minOffset) / 2);\n        }\n\n      case AUTO_ALIGNMENT:\n      default:\n        {\n          if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {\n            return scrollOffset;\n          } else if (scrollOffset < minOffset) {\n            return minOffset;\n          } else {\n            return maxOffset;\n          }\n        }\n    }\n  },\n  getStartIndexForOffset: (props, offset, listCache) => findItem(props, listCache, offset),\n  getStopIndexForStartIndex: (props, startIndex, scrollOffset, listCache) => {\n    const {\n      height,\n      total,\n      layout,\n      width\n    } = props;\n    const size = isHorizontal(layout) ? width : height;\n    const item = getItemFromCache(props, startIndex, listCache);\n    const maxOffset = scrollOffset + size;\n    let offset = item.offset + item.size;\n    let stopIndex = startIndex;\n\n    while (stopIndex < total - 1 && offset < maxOffset) {\n      stopIndex++;\n      offset += getItemFromCache(props, stopIndex, listCache).size;\n    }\n\n    return stopIndex;\n  },\n\n  initCache({\n    estimatedItemSize = DEFAULT_DYNAMIC_LIST_ITEM_SIZE\n  }, instance) {\n    const cache = {\n      items: {},\n      estimatedItemSize,\n      lastVisitedIndex: -1\n    };\n\n    cache.clearCacheAfterIndex = (index, forceUpdate = true) => {\n      cache.lastVisitedIndex = Math.min(cache.lastVisitedIndex, index - 1);\n      instance.exposed.getItemStyleCache(-1);\n\n      if (forceUpdate) {\n        instance.proxy.$forceUpdate();\n      }\n    };\n\n    return cache;\n  },\n\n  clearCache: false,\n  validateProps: ({\n    itemSize\n  }) => {\n    if (process.env.NODE_ENV !== \"production\") {\n      if (typeof itemSize !== \"function\") {\n        throwError(SCOPE, `\n          itemSize is required as function, but the given value was ${typeof itemSize}\n        `);\n      }\n    }\n  }\n});\nvar __defProp$2 = Object.defineProperty;\nvar __defProps$2 = Object.defineProperties;\nvar __getOwnPropDescs$2 = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols$2 = Object.getOwnPropertySymbols;\nvar __hasOwnProp$2 = Object.prototype.hasOwnProperty;\nvar __propIsEnum$2 = Object.prototype.propertyIsEnumerable;\n\nvar __defNormalProp$2 = (obj, key, value) => key in obj ? __defProp$2(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\n\nvar __spreadValues$2 = (a, b) => {\n  for (var prop in b || (b = {})) if (__hasOwnProp$2.call(b, prop)) __defNormalProp$2(a, prop, b[prop]);\n\n  if (__getOwnPropSymbols$2) for (var prop of __getOwnPropSymbols$2(b)) {\n    if (__propIsEnum$2.call(b, prop)) __defNormalProp$2(a, prop, b[prop]);\n  }\n  return a;\n};\n\nvar __spreadProps$2 = (a, b) => __defProps$2(a, __getOwnPropDescs$2(b));\n\nconst createGrid = ({\n  name,\n  clearCache,\n  getColumnPosition,\n  getColumnStartIndexForOffset,\n  getColumnStopIndexForStartIndex,\n  getEstimatedTotalHeight,\n  getEstimatedTotalWidth,\n  getColumnOffset,\n  getRowOffset,\n  getRowPosition,\n  getRowStartIndexForOffset,\n  getRowStopIndexForStartIndex,\n  initCache,\n  validateProps\n}) => {\n  return defineComponent({\n    name: name != null ? name : \"ElVirtualList\",\n    props: DefaultGridProps,\n    emits: [ITEM_RENDER_EVT, SCROLL_EVT],\n\n    setup(props, {\n      emit,\n      expose\n    }) {\n      validateProps(props);\n      const instance = getCurrentInstance();\n      const cache = ref(initCache(props, instance));\n      const windowRef = ref(null);\n      const innerRef = ref(null);\n      const states = ref({\n        isScrolling: false,\n        scrollLeft: isNumber(props.initScrollLeft) ? props.initScrollLeft : 0,\n        scrollTop: isNumber(props.initScrollTop) ? props.initScrollTop : 0,\n        updateRequested: false,\n        xAxisScrollDir: FORWARD,\n        yAxisScrollDir: FORWARD\n      });\n      const columnsToRender = computed(() => {\n        const {\n          totalColumn,\n          totalRow,\n          columnCache\n        } = props;\n        const {\n          isScrolling,\n          xAxisScrollDir,\n          scrollLeft\n        } = $(states);\n\n        if (totalColumn === 0 || totalRow === 0) {\n          return [0, 0, 0, 0];\n        }\n\n        const startIndex = getColumnStartIndexForOffset(props, scrollLeft, $(cache));\n        const stopIndex = getColumnStopIndexForStartIndex(props, startIndex, scrollLeft, $(cache));\n        const cacheBackward = !isScrolling || xAxisScrollDir === BACKWARD ? Math.max(1, columnCache) : 1;\n        const cacheForward = !isScrolling || xAxisScrollDir === FORWARD ? Math.max(1, columnCache) : 1;\n        return [Math.max(0, startIndex - cacheBackward), Math.max(0, Math.min(totalColumn - 1, stopIndex + cacheForward)), startIndex, stopIndex];\n      });\n      const rowsToRender = computed(() => {\n        const {\n          totalColumn,\n          totalRow,\n          rowCache\n        } = props;\n        const {\n          isScrolling,\n          yAxisScrollDir,\n          scrollTop\n        } = $(states);\n\n        if (totalColumn === 0 || totalRow === 0) {\n          return [0, 0, 0, 0];\n        }\n\n        const startIndex = getRowStartIndexForOffset(props, scrollTop, $(cache));\n        const stopIndex = getRowStopIndexForStartIndex(props, startIndex, scrollTop, $(cache));\n        const cacheBackward = !isScrolling || yAxisScrollDir === BACKWARD ? Math.max(1, rowCache) : 1;\n        const cacheForward = !isScrolling || yAxisScrollDir === FORWARD ? Math.max(1, rowCache) : 1;\n        return [Math.max(0, startIndex - cacheBackward), Math.max(0, Math.min(totalRow - 1, stopIndex + cacheForward)), startIndex, stopIndex];\n      });\n      const estimatedTotalHeight = computed(() => getEstimatedTotalHeight(props, $(cache)));\n      const estimatedTotalWidth = computed(() => getEstimatedTotalWidth(props, $(cache)));\n      const windowStyle = computed(() => [{\n        position: \"relative\",\n        overflow: \"auto\",\n        WebkitOverflowScrolling: \"touch\",\n        willChange: \"transform\"\n      }, __spreadValues$2({\n        direction: props.direction,\n        height: isNumber(props.height) ? `${props.height}px` : props.height,\n        width: isNumber(props.width) ? `${props.width}px` : props.width\n      }, props.style)]);\n      const innerStyle = computed(() => {\n        const width = `${$(estimatedTotalWidth)}px`;\n        const height = `${$(estimatedTotalHeight)}px`;\n        return {\n          height,\n          pointerEvents: $(states).isScrolling ? \"none\" : void 0,\n          width\n        };\n      });\n\n      const emitEvents = () => {\n        const {\n          totalColumn,\n          totalRow\n        } = props;\n\n        if (totalColumn > 0 && totalRow > 0) {\n          const [columnCacheStart, columnCacheEnd, columnVisibleStart, columnVisibleEnd] = $(columnsToRender);\n          const [rowCacheStart, rowCacheEnd, rowVisibleStart, rowVisibleEnd] = $(rowsToRender);\n          emit(ITEM_RENDER_EVT, columnCacheStart, columnCacheEnd, rowCacheStart, rowCacheEnd, columnVisibleStart, columnVisibleEnd, rowVisibleStart, rowVisibleEnd);\n        }\n\n        const {\n          scrollLeft,\n          scrollTop,\n          updateRequested,\n          xAxisScrollDir,\n          yAxisScrollDir\n        } = $(states);\n        emit(SCROLL_EVT, xAxisScrollDir, scrollLeft, yAxisScrollDir, scrollTop, updateRequested);\n      };\n\n      const onScroll = e => {\n        const {\n          clientHeight,\n          clientWidth,\n          scrollHeight,\n          scrollLeft,\n          scrollTop,\n          scrollWidth\n        } = e.currentTarget;\n\n        const _states = $(states);\n\n        if (_states.scrollTop === scrollTop && _states.scrollLeft === scrollLeft) {\n          return;\n        }\n\n        let _scrollLeft = scrollLeft;\n\n        if (isRTL(props.direction)) {\n          switch (getRTLOffsetType()) {\n            case RTL_OFFSET_NAG:\n              _scrollLeft = -scrollLeft;\n              break;\n\n            case RTL_OFFSET_POS_DESC:\n              _scrollLeft = scrollWidth - clientWidth - scrollLeft;\n              break;\n          }\n        }\n\n        states.value = __spreadProps$2(__spreadValues$2({}, _states), {\n          isScrolling: true,\n          scrollLeft: _scrollLeft,\n          scrollTop: Math.max(0, Math.min(scrollTop, scrollHeight - clientHeight)),\n          updateRequested: false,\n          xAxisScrollDir: getScrollDir(_states.scrollLeft, _scrollLeft),\n          yAxisScrollDir: getScrollDir(_states.scrollTop, scrollTop)\n        });\n        nextTick(resetIsScrolling);\n        emitEvents();\n      };\n\n      const getItemStyleCache = memo((_, __, ___) => ({}));\n\n      const scrollTo = ({\n        scrollLeft,\n        scrollTop\n      }) => {\n        scrollLeft = Math.max(scrollLeft, 0);\n        scrollTop = Math.max(scrollTop, 0);\n\n        const _states = $(states);\n\n        if (scrollTop === _states.scrollTop && scrollLeft === _states.scrollLeft) {\n          return;\n        }\n\n        states.value = __spreadProps$2(__spreadValues$2({}, _states), {\n          xAxisScrollDir: getScrollDir(_states.scrollLeft, scrollLeft),\n          yAxisScrollDir: getScrollDir(_states.scrollTop, scrollTop),\n          scrollLeft,\n          scrollTop,\n          updateRequested: true\n        });\n        nextTick(resetIsScrolling);\n      };\n\n      const scrollToItem = (rowIndex = 0, columnIdx = 0, alignment = AUTO_ALIGNMENT) => {\n        const _states = $(states);\n\n        columnIdx = Math.max(0, Math.min(columnIdx, props.totalColumn - 1));\n        rowIndex = Math.max(0, Math.min(rowIndex, props.totalRow - 1));\n        const scrollBarWidth = getScrollBarWidth();\n\n        const _cache = $(cache);\n\n        const estimatedHeight = getEstimatedTotalHeight(props, _cache);\n        const estimatedWidth = getEstimatedTotalWidth(props, _cache);\n        scrollTo({\n          scrollLeft: getColumnOffset(props, columnIdx, alignment, _states.scrollLeft, _cache, estimatedWidth > props.width ? scrollBarWidth : 0),\n          scrollTop: getRowOffset(props, rowIndex, alignment, _states.scrollTop, _cache, estimatedHeight > props.height ? scrollBarWidth : 0)\n        });\n      };\n\n      const getItemStyle = (rowIndex, columnIndex) => {\n        const {\n          columnWidth,\n          direction,\n          rowHeight\n        } = props;\n        const itemStyleCache = getItemStyleCache(clearCache && columnWidth, clearCache && rowHeight, clearCache && direction);\n        const key = `${rowIndex},${columnIndex}`;\n\n        if (hasOwn(itemStyleCache, key)) {\n          return itemStyleCache[key];\n        } else {\n          const [, left] = getColumnPosition(props, columnIndex, $(cache));\n\n          const _cache = $(cache);\n\n          const rtl = isRTL(direction);\n          const [height, top] = getRowPosition(props, rowIndex, _cache);\n          const [width] = getColumnPosition(props, columnIndex, _cache);\n          itemStyleCache[key] = {\n            position: \"absolute\",\n            left: rtl ? void 0 : `${left}px`,\n            right: rtl ? `${left}px` : void 0,\n            top: `${top}px`,\n            height: `${height}px`,\n            width: `${width}px`\n          };\n          return itemStyleCache[key];\n        }\n      };\n\n      const resetIsScrolling = () => {\n        states.value.isScrolling = false;\n        nextTick(() => {\n          getItemStyleCache(-1, null, null);\n        });\n      };\n\n      onMounted(() => {\n        if (isServer) return;\n        const {\n          initScrollLeft,\n          initScrollTop\n        } = props;\n        const windowElement = $(windowRef);\n\n        if (windowElement !== null) {\n          if (isNumber(initScrollLeft)) {\n            windowElement.scrollLeft = initScrollLeft;\n          }\n\n          if (isNumber(initScrollTop)) {\n            windowElement.scrollTop = initScrollTop;\n          }\n        }\n\n        emitEvents();\n      });\n      onUpdated(() => {\n        const {\n          direction\n        } = props;\n        const {\n          scrollLeft,\n          scrollTop,\n          updateRequested\n        } = $(states);\n\n        if (updateRequested && $(windowRef) !== null) {\n          const windowElement = $(windowRef);\n\n          if (direction === RTL) {\n            switch (getRTLOffsetType()) {\n              case RTL_OFFSET_NAG:\n                {\n                  windowElement.scrollLeft = -scrollLeft;\n                  break;\n                }\n\n              case RTL_OFFSET_POS_ASC:\n                {\n                  windowElement.scrollLeft = scrollLeft;\n                  break;\n                }\n\n              default:\n                {\n                  const {\n                    clientWidth,\n                    scrollWidth\n                  } = windowElement;\n                  windowElement.scrollLeft = scrollWidth - clientWidth - scrollLeft;\n                  break;\n                }\n            }\n          } else {\n            windowElement.scrollLeft = Math.max(0, scrollLeft);\n          }\n\n          windowElement.scrollTop = Math.max(0, scrollTop);\n        }\n      });\n      const api = {\n        windowStyle,\n        windowRef,\n        columnsToRender,\n        innerRef,\n        innerStyle,\n        states,\n        rowsToRender,\n        getItemStyle,\n        onScroll,\n        scrollTo,\n        scrollToItem\n      };\n      expose({\n        windowRef,\n        innerRef,\n        getItemStyleCache,\n        scrollTo,\n        scrollToItem,\n        states\n      });\n      return api;\n    },\n\n    render(ctx) {\n      var _a;\n\n      const {\n        $slots,\n        className,\n        containerElement,\n        columnsToRender,\n        data,\n        getItemStyle,\n        innerElement,\n        innerStyle,\n        rowsToRender,\n        onScroll,\n        states,\n        useIsScrolling,\n        windowStyle,\n        totalColumn,\n        totalRow\n      } = ctx;\n      const [columnStart, columnEnd] = columnsToRender;\n      const [rowStart, rowEnd] = rowsToRender;\n      const Container = resolveDynamicComponent(containerElement);\n      const Inner = resolveDynamicComponent(innerElement);\n      const children = [];\n\n      if (totalRow > 0 && totalColumn > 0) {\n        for (let row = rowStart; row <= rowEnd; row++) {\n          for (let column = columnStart; column <= columnEnd; column++) {\n            children.push((_a = $slots.default) == null ? void 0 : _a.call($slots, {\n              columnIndex: column,\n              data,\n              key: column,\n              isScrolling: useIsScrolling ? states.isScrolling : void 0,\n              style: getItemStyle(row, column),\n              rowIndex: row\n            }));\n          }\n        }\n      }\n\n      const InnerNode = [h(Inner, {\n        style: innerStyle,\n        ref: \"innerRef\"\n      }, !isString(Inner) ? {\n        default: () => children\n      } : children)];\n      return h(Container, {\n        class: className,\n        style: windowStyle,\n        onScroll,\n        ref: \"windowRef\"\n      }, !isString(Container) ? {\n        default: () => InnerNode\n      } : InnerNode);\n    }\n\n  });\n};\n\nconst SCOPE$1 = \"ElFixedSizeGrid\";\nconst FixedSizeGrid = createGrid({\n  name: \"ElFixedSizeGrid\",\n  getColumnPosition: ({\n    columnWidth\n  }, index) => [columnWidth, index * columnWidth],\n  getRowPosition: ({\n    rowHeight\n  }, index) => [rowHeight, index * rowHeight],\n  getEstimatedTotalHeight: ({\n    totalRow,\n    rowHeight\n  }) => rowHeight * totalRow,\n  getEstimatedTotalWidth: ({\n    totalColumn,\n    columnWidth\n  }) => columnWidth * totalColumn,\n  getColumnOffset: ({\n    totalColumn,\n    columnWidth,\n    width\n  }, columnIndex, alignment, scrollLeft, _, scrollBarWidth) => {\n    width = Number(width);\n    const lastColumnOffset = Math.max(0, totalColumn * columnWidth - width);\n    const maxOffset = Math.min(lastColumnOffset, columnIndex * columnWidth);\n    const minOffset = Math.max(0, columnIndex * columnWidth - width + scrollBarWidth + columnWidth);\n\n    if (alignment === \"smart\") {\n      if (scrollLeft >= minOffset - width && scrollLeft <= maxOffset + width) {\n        alignment = AUTO_ALIGNMENT;\n      } else {\n        alignment = CENTERED_ALIGNMENT;\n      }\n    }\n\n    switch (alignment) {\n      case START_ALIGNMENT:\n        return maxOffset;\n\n      case END_ALIGNMENT:\n        return minOffset;\n\n      case CENTERED_ALIGNMENT:\n        const middleOffset = Math.round(minOffset + (maxOffset - minOffset) / 2);\n\n        if (middleOffset < Math.ceil(width / 2)) {\n          return 0;\n        } else if (middleOffset > lastColumnOffset + Math.floor(width / 2)) {\n          return lastColumnOffset;\n        } else {\n          return middleOffset;\n        }\n\n      case AUTO_ALIGNMENT:\n      default:\n        if (scrollLeft >= minOffset && scrollLeft <= maxOffset) {\n          return scrollLeft;\n        } else if (minOffset > maxOffset) {\n          return minOffset;\n        } else if (scrollLeft < minOffset) {\n          return minOffset;\n        } else {\n          return maxOffset;\n        }\n\n    }\n  },\n  getRowOffset: ({\n    rowHeight,\n    height,\n    totalRow\n  }, rowIndex, align, scrollTop, _, scrollBarWidth) => {\n    height = Number(height);\n    const lastRowOffset = Math.max(0, totalRow * rowHeight - height);\n    const maxOffset = Math.min(lastRowOffset, rowIndex * rowHeight);\n    const minOffset = Math.max(0, rowIndex * rowHeight - height + scrollBarWidth + rowHeight);\n\n    if (align === SMART_ALIGNMENT) {\n      if (scrollTop >= minOffset - height && scrollTop <= maxOffset + height) {\n        align = AUTO_ALIGNMENT;\n      } else {\n        align = CENTERED_ALIGNMENT;\n      }\n    }\n\n    switch (align) {\n      case START_ALIGNMENT:\n        return maxOffset;\n\n      case END_ALIGNMENT:\n        return minOffset;\n\n      case CENTERED_ALIGNMENT:\n        const middleOffset = Math.round(minOffset + (maxOffset - minOffset) / 2);\n\n        if (middleOffset < Math.ceil(height / 2)) {\n          return 0;\n        } else if (middleOffset > lastRowOffset + Math.floor(height / 2)) {\n          return lastRowOffset;\n        } else {\n          return middleOffset;\n        }\n\n      case AUTO_ALIGNMENT:\n      default:\n        if (scrollTop >= minOffset && scrollTop <= maxOffset) {\n          return scrollTop;\n        } else if (minOffset > maxOffset) {\n          return minOffset;\n        } else if (scrollTop < minOffset) {\n          return minOffset;\n        } else {\n          return maxOffset;\n        }\n\n    }\n  },\n  getColumnStartIndexForOffset: ({\n    columnWidth,\n    totalColumn\n  }, scrollLeft) => Math.max(0, Math.min(totalColumn - 1, Math.floor(scrollLeft / columnWidth))),\n  getColumnStopIndexForStartIndex: ({\n    columnWidth,\n    totalColumn,\n    width\n  }, startIndex, scrollLeft) => {\n    const left = startIndex * columnWidth;\n    const visibleColumnsCount = Math.ceil((width + scrollLeft - left) / columnWidth);\n    return Math.max(0, Math.min(totalColumn - 1, startIndex + visibleColumnsCount - 1));\n  },\n  getRowStartIndexForOffset: ({\n    rowHeight,\n    totalRow\n  }, scrollTop) => Math.max(0, Math.min(totalRow - 1, Math.floor(scrollTop / rowHeight))),\n  getRowStopIndexForStartIndex: ({\n    rowHeight,\n    totalRow,\n    height\n  }, startIndex, scrollTop) => {\n    const top = startIndex * rowHeight;\n    const numVisibleRows = Math.ceil((height + scrollTop - top) / rowHeight);\n    return Math.max(0, Math.min(totalRow - 1, startIndex + numVisibleRows - 1));\n  },\n  initCache: () => void 0,\n  clearCache: true,\n  validateProps: ({\n    columnWidth,\n    rowHeight\n  }) => {\n    if (process.env.NODE_ENV !== \"production\") {\n      if (!isNumber(columnWidth)) {\n        throwError(SCOPE$1, `\n          \"columnWidth\" must be passed as number,\n            instead ${typeof columnWidth} was given.\n        `);\n      }\n\n      if (!isNumber(rowHeight)) {\n        throwError(SCOPE$1, `\n          \"columnWidth\" must be passed as number,\n            instead ${typeof rowHeight} was given.\n        `);\n      }\n    }\n  }\n});\nconst {\n  max,\n  min,\n  floor\n} = Math;\nconst SCOPE$2 = \"ElDynamicSizeGrid\";\nconst ACCESS_SIZER_KEY_MAP = {\n  column: \"columnWidth\",\n  row: \"rowHeight\"\n};\nconst ACCESS_LAST_VISITED_KEY_MAP = {\n  column: \"lastVisitedColumnIndex\",\n  row: \"lastVisitedRowIndex\"\n};\n\nconst getItemFromCache$1 = (props, index, gridCache, type) => {\n  const [cachedItems, sizer, lastVisited] = [gridCache[type], props[ACCESS_SIZER_KEY_MAP[type]], gridCache[ACCESS_LAST_VISITED_KEY_MAP[type]]];\n\n  if (index > lastVisited) {\n    let offset = 0;\n\n    if (lastVisited >= 0) {\n      const item = cachedItems[lastVisited];\n      offset = item.offset + item.size;\n    }\n\n    for (let i = lastVisited + 1; i <= index; i++) {\n      const size = sizer(i);\n      cachedItems[i] = {\n        offset,\n        size\n      };\n      offset += size;\n    }\n\n    gridCache[ACCESS_LAST_VISITED_KEY_MAP[type]] = index;\n  }\n\n  return cachedItems[index];\n};\n\nconst bs$1 = (props, gridCache, low, high, offset, type) => {\n  while (low <= high) {\n    const mid = low + floor((high - low) / 2);\n    const currentOffset = getItemFromCache$1(props, mid, gridCache, type).offset;\n\n    if (currentOffset === offset) {\n      return mid;\n    } else if (currentOffset < offset) {\n      low = mid + 1;\n    } else {\n      high = mid - 1;\n    }\n  }\n\n  return max(0, low - 1);\n};\n\nconst es$1 = (props, gridCache, idx, offset, type) => {\n  const total = type === \"column\" ? props.totalColumn : props.totalRow;\n  let exponent = 1;\n\n  while (idx < total && getItemFromCache$1(props, idx, gridCache, type).offset < offset) {\n    idx += exponent;\n    exponent *= 2;\n  }\n\n  return bs$1(props, gridCache, floor(idx / 2), min(idx, total - 1), offset, type);\n};\n\nconst findItem$1 = (props, gridCache, offset, type) => {\n  const [cache, lastVisitedIndex] = [gridCache[type], gridCache[ACCESS_LAST_VISITED_KEY_MAP[type]]];\n  const lastVisitedItemOffset = lastVisitedIndex > 0 ? cache[lastVisitedIndex].offset : 0;\n\n  if (lastVisitedItemOffset >= offset) {\n    return bs$1(props, gridCache, 0, lastVisitedIndex, offset, type);\n  }\n\n  return es$1(props, gridCache, max(0, lastVisitedIndex), offset, type);\n};\n\nconst getEstimatedTotalHeight = ({\n  totalRow\n}, {\n  estimatedRowHeight,\n  lastVisitedRowIndex,\n  row\n}) => {\n  let sizeOfVisitedRows = 0;\n\n  if (lastVisitedRowIndex >= totalRow) {\n    lastVisitedRowIndex = totalRow - 1;\n  }\n\n  if (lastVisitedRowIndex >= 0) {\n    const item = row[lastVisitedRowIndex];\n    sizeOfVisitedRows = item.offset + item.size;\n  }\n\n  const unvisitedItems = totalRow - lastVisitedRowIndex - 1;\n  const sizeOfUnvisitedItems = unvisitedItems * estimatedRowHeight;\n  return sizeOfVisitedRows + sizeOfUnvisitedItems;\n};\n\nconst getEstimatedTotalWidth = ({\n  totalColumn\n}, {\n  column,\n  estimatedColumnWidth,\n  lastVisitedColumnIndex\n}) => {\n  let sizeOfVisitedColumns = 0;\n\n  if (lastVisitedColumnIndex > totalColumn) {\n    lastVisitedColumnIndex = totalColumn - 1;\n  }\n\n  if (lastVisitedColumnIndex >= 0) {\n    const item = column[lastVisitedColumnIndex];\n    sizeOfVisitedColumns = item.offset + item.size;\n  }\n\n  const unvisitedItems = totalColumn - lastVisitedColumnIndex - 1;\n  const sizeOfUnvisitedItems = unvisitedItems * estimatedColumnWidth;\n  return sizeOfVisitedColumns + sizeOfUnvisitedItems;\n};\n\nconst ACCESS_ESTIMATED_SIZE_KEY_MAP = {\n  column: getEstimatedTotalWidth,\n  row: getEstimatedTotalHeight\n};\n\nconst getOffset = (props, index, alignment, scrollOffset, cache, type, scrollBarWidth) => {\n  const [size, estimatedSizeAssociates] = [type === \"row\" ? props.height : props.width, ACCESS_ESTIMATED_SIZE_KEY_MAP[type]];\n  const item = getItemFromCache$1(props, index, cache, type);\n  const estimatedSize = estimatedSizeAssociates(props, cache);\n  const maxOffset = max(0, min(estimatedSize - size, item.offset));\n  const minOffset = max(0, item.offset - size + scrollBarWidth + item.size);\n\n  if (alignment === SMART_ALIGNMENT) {\n    if (scrollOffset >= minOffset - size && scrollOffset <= maxOffset + size) {\n      alignment = AUTO_ALIGNMENT;\n    } else {\n      alignment = CENTERED_ALIGNMENT;\n    }\n  }\n\n  switch (alignment) {\n    case START_ALIGNMENT:\n      {\n        return maxOffset;\n      }\n\n    case END_ALIGNMENT:\n      {\n        return minOffset;\n      }\n\n    case CENTERED_ALIGNMENT:\n      {\n        return Math.round(minOffset + (maxOffset - minOffset) / 2);\n      }\n\n    case AUTO_ALIGNMENT:\n    default:\n      {\n        if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {\n          return scrollOffset;\n        } else if (minOffset > maxOffset) {\n          return minOffset;\n        } else if (scrollOffset < minOffset) {\n          return minOffset;\n        } else {\n          return maxOffset;\n        }\n      }\n  }\n};\n\nconst FixedSizeGrid$1 = createGrid({\n  name: \"ElDynamicSizeGrid\",\n  getColumnPosition: (props, idx, cache) => {\n    const item = getItemFromCache$1(props, idx, cache, \"column\");\n    return [item.size, item.offset];\n  },\n  getRowPosition: (props, idx, cache) => {\n    const item = getItemFromCache$1(props, idx, cache, \"row\");\n    return [item.size, item.offset];\n  },\n  getColumnOffset: (props, columnIndex, alignment, scrollLeft, cache, scrollBarWidth) => getOffset(props, columnIndex, alignment, scrollLeft, cache, \"column\", scrollBarWidth),\n  getRowOffset: (props, rowIndex, alignment, scrollTop, cache, scrollBarWidth) => getOffset(props, rowIndex, alignment, scrollTop, cache, \"row\", scrollBarWidth),\n  getColumnStartIndexForOffset: (props, scrollLeft, cache) => findItem$1(props, cache, scrollLeft, \"column\"),\n  getColumnStopIndexForStartIndex: (props, startIndex, scrollLeft, cache) => {\n    const item = getItemFromCache$1(props, startIndex, cache, \"column\");\n    const maxOffset = scrollLeft + props.width;\n    let offset = item.offset + item.size;\n    let stopIndex = startIndex;\n\n    while (stopIndex < props.totalColumn - 1 && offset < maxOffset) {\n      stopIndex++;\n      offset += getItemFromCache$1(props, startIndex, cache, \"column\").size;\n    }\n\n    return stopIndex;\n  },\n  getEstimatedTotalHeight,\n  getEstimatedTotalWidth,\n  getRowStartIndexForOffset: (props, scrollTop, cache) => findItem$1(props, cache, scrollTop, \"row\"),\n  getRowStopIndexForStartIndex: (props, startIndex, scrollTop, cache) => {\n    const {\n      totalRow,\n      height\n    } = props;\n    const item = getItemFromCache$1(props, startIndex, cache, \"row\");\n    const maxOffset = scrollTop + height;\n    let offset = item.size + item.offset;\n    let stopIndex = startIndex;\n\n    while (stopIndex < totalRow - 1 && offset < maxOffset) {\n      stopIndex++;\n      offset += getItemFromCache$1(props, stopIndex, cache, \"row\").size;\n    }\n\n    return stopIndex;\n  },\n  initCache: ({\n    estimatedColumnWidth = DEFAULT_DYNAMIC_LIST_ITEM_SIZE,\n    estimatedRowHeight = DEFAULT_DYNAMIC_LIST_ITEM_SIZE\n  }) => {\n    const cache = {\n      column: {},\n      estimatedColumnWidth,\n      estimatedRowHeight,\n      lastVisitedColumnIndex: -1,\n      lastVisitedRowIndex: -1,\n      row: {}\n    };\n    return cache;\n  },\n  clearCache: true,\n  validateProps: ({\n    columnWidth,\n    rowHeight\n  }) => {\n    if (process.env.NODE_ENV !== \"production\") {\n      if (!isFunction(columnWidth)) {\n        throwError(SCOPE$2, `\n          \"columnWidth\" must be passed as function,\n            instead ${typeof columnWidth} was given.\n        `);\n      }\n\n      if (!isFunction(rowHeight)) {\n        throwError(SCOPE$2, `\n          \"columnWidth\" must be passed as function,\n            instead ${typeof rowHeight} was given.\n        `);\n      }\n    }\n  }\n});\nexport { FixedSizeGrid$1 as DynamicSizeGrid, DynamicSizeList, FixedSizeGrid, FixedSizeList };","map":{"version":3,"names":["isNumber","$","isString","throwError","defineComponent","ref","reactive","computed","watch","onMounted","onBeforeUnmount","h","withModifiers","getCurrentInstance","onUpdated","resolveDynamicComponent","nextTick","memo","isServer","cAF","rAF","on","off","getScrollBarWidth","EMPTY_OBJ","process","env","NODE_ENV","Object","freeze","EMPTY_ARR","NOOP","hasOwnProperty","prototype","hasOwn","val","key","call","isFunction","isObject","__defProp","defineProperty","__defProps","defineProperties","__getOwnPropDescs","getOwnPropertyDescriptors","__getOwnPropSymbols","getOwnPropertySymbols","__hasOwnProp","__propIsEnum","propertyIsEnumerable","__defNormalProp","obj","value","enumerable","configurable","writable","__spreadValues","a","b","prop","__spreadProps","DEFAULT_DYNAMIC_LIST_ITEM_SIZE","ITEM_RENDER_EVT","SCROLL_EVT","FORWARD","BACKWARD","AUTO_ALIGNMENT","SMART_ALIGNMENT","START_ALIGNMENT","CENTERED_ALIGNMENT","END_ALIGNMENT","HORIZONTAL","VERTICAL","LTR","RTL","RTL_OFFSET_NAG","RTL_OFFSET_POS_ASC","RTL_OFFSET_POS_DESC","DefaultListProps","cache","type","Number","default","className","String","containerElement","data","Array","direction","validator","estimatedItemSize","height","required","layout","initScrollOffset","innerElement","total","itemSize","Function","style","useIsScrolling","Boolean","width","DefaultGridProps","columnCache","columnWidth","estimatedColumnWidth","estimatedRowHeight","initScrollLeft","initScrollTop","rowCache","rowHeight","totalColumn","totalRow","DefaultScrollBarProps","ratio","clientSize","scrollFrom","visible","ScrollbarDirKey","SCROLLBAR_MIN_SIZE","getScrollDir","prev","cur","isHorizontal","dir","isRTL","cachedRTLResult","getRTLOffsetType","recalculate","outerDiv","document","createElement","outerStyle","overflow","innerDiv","innerStyle","appendChild","body","scrollLeft","removeChild","renderThumbStyle","move","size","bar","translate","axis","transform","msTransform","webkitTransform","isFF","navigator","test","userAgent","LayoutKeys","useWheel","atEndEdge","atStartEdge","onWheelDelta","frameHandle","offset","hasReachedEdge","offset2","edgeReached","onWheel","e","newOffset","preventDefault","BAR_MAP","vertical","scroll","scrollSize","client","horizontal","ScrollBar","name","props","emits","setup","emit","trackRef","thumbRef","onselectstartStore","state","isDragging","traveled","trackStyle","display","position","right","bottom","borderRadius","thumbSize","POSITIVE_INFINITY","SCROLLBAR_MAX_SIZE","Math","floor","min","max","thumbStyle","isFinite","thumb","totalSteps","attachEvents","window","onMouseMove","onMouseUp","thumbEl","onselectstart","detachEvents","onThumbMouseDown","stopImmediatePropagation","ctrlKey","includes","button","currentTarget","getBoundingClientRect","prevPage","thumbClickPosition","distance","onScrollbarTouchStart","v","ceil","role","class","onMousedown","__defProp$1","__defProps$1","__getOwnPropDescs$1","__getOwnPropSymbols$1","__hasOwnProp$1","__propIsEnum$1","__defNormalProp$1","__spreadValues$1","__spreadProps$1","createList","getOffset","getItemSize","getItemOffset","getEstimatedTotalSize","getStartIndexForOffset","getStopIndexForStartIndex","initCache","clearCache","validateProps","expose","instance","dynamicSizeCache","windowRef","innerRef","scrollbarRef","states","isScrolling","scrollDir","scrollOffset","updateRequested","isScrollbarDragging","itemsToRender","startIndex","stopIndex","cacheBackward","cacheForward","estimatedTotalSize","_isHorizontal","windowStyle","WebkitOverflowScrolling","willChange","pointerEvents","_a","_b","scrollTo","emitEvents","cacheStart","cacheEnd","visibleStart","visibleEnd","scrollVertically","clientHeight","scrollHeight","scrollTop","_states","resetIsScrolling","scrollHorizontally","clientWidth","scrollWidth","onScroll","onScrollbarScroll","distanceToGo","getItemStyleCache","_","__","___","scrollToItem","idx","alignment","getItemStyle","itemStyleCache","isRtl","offsetHorizontal","left","top","windowElement","api","render","ctx","$slots","start","end","Container","Inner","children","i","push","index","InnerNode","scrollbar","listContainer","FixedSizeList","ENV","lastItemOffset","maxOffset","minOffset","middleOffset","round","numVisibleItems","SCOPE","getItemFromCache","listCache","items","lastVisitedIndex","item","findItem","lastVisitedOffset","bs","es","low","high","mid","currentOffset","exponent","totalSizeOfMeasuredItems","numUnmeasuredItems","totalSizeOfUnmeasuredItems","DynamicSizeList","clearCacheAfterIndex","forceUpdate","exposed","proxy","$forceUpdate","__defProp$2","__defProps$2","__getOwnPropDescs$2","__getOwnPropSymbols$2","__hasOwnProp$2","__propIsEnum$2","__defNormalProp$2","__spreadValues$2","__spreadProps$2","createGrid","getColumnPosition","getColumnStartIndexForOffset","getColumnStopIndexForStartIndex","getEstimatedTotalHeight","getEstimatedTotalWidth","getColumnOffset","getRowOffset","getRowPosition","getRowStartIndexForOffset","getRowStopIndexForStartIndex","xAxisScrollDir","yAxisScrollDir","columnsToRender","rowsToRender","estimatedTotalHeight","estimatedTotalWidth","columnCacheStart","columnCacheEnd","columnVisibleStart","columnVisibleEnd","rowCacheStart","rowCacheEnd","rowVisibleStart","rowVisibleEnd","_scrollLeft","rowIndex","columnIdx","scrollBarWidth","_cache","estimatedHeight","estimatedWidth","columnIndex","rtl","columnStart","columnEnd","rowStart","rowEnd","row","column","SCOPE$1","FixedSizeGrid","lastColumnOffset","align","lastRowOffset","visibleColumnsCount","numVisibleRows","SCOPE$2","ACCESS_SIZER_KEY_MAP","ACCESS_LAST_VISITED_KEY_MAP","getItemFromCache$1","gridCache","cachedItems","sizer","lastVisited","bs$1","es$1","findItem$1","lastVisitedItemOffset","lastVisitedRowIndex","sizeOfVisitedRows","unvisitedItems","sizeOfUnvisitedItems","lastVisitedColumnIndex","sizeOfVisitedColumns","ACCESS_ESTIMATED_SIZE_KEY_MAP","estimatedSizeAssociates","estimatedSize","FixedSizeGrid$1","DynamicSizeGrid"],"sources":["D:/project/my_blog/blog-ui/node_modules/element-plus/es/el-virtual-list/index.js"],"sourcesContent":["import { isNumber, $, isString } from '../utils/util';\nimport throwError from '../utils/error';\nimport { defineComponent, ref, reactive, computed, watch, onMounted, onBeforeUnmount, h, withModifiers, getCurrentInstance, onUpdated, resolveDynamicComponent, nextTick } from 'vue';\nimport memo from 'lodash/memoize';\nimport isServer from '../utils/isServer';\nimport { cAF, rAF } from '../utils/raf';\nimport { on, off } from '../utils/dom';\nimport getScrollBarWidth from '../utils/scrollbar-width';\n\n/**\r\n * Make a map and return a function for checking if a key\r\n * is in that map.\r\n * IMPORTANT: all calls of this function must be prefixed with\r\n * \\/\\*#\\_\\_PURE\\_\\_\\*\\/\r\n * So that rollup can tree-shake them if necessary.\r\n */\r\nconst EMPTY_OBJ = (process.env.NODE_ENV !== 'production')\r\n    ? Object.freeze({})\r\n    : {};\r\nconst EMPTY_ARR = (process.env.NODE_ENV !== 'production') ? Object.freeze([]) : [];\r\nconst NOOP = () => { };\r\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\r\nconst hasOwn = (val, key) => hasOwnProperty.call(val, key);\r\nconst isFunction = (val) => typeof val === 'function';\r\nconst isObject = (val) => val !== null && typeof val === 'object';\n\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nconst DEFAULT_DYNAMIC_LIST_ITEM_SIZE = 50;\nconst ITEM_RENDER_EVT = \"item-rendered\";\nconst SCROLL_EVT = \"scroll\";\nconst FORWARD = \"forward\";\nconst BACKWARD = \"backward\";\nconst AUTO_ALIGNMENT = \"auto\";\nconst SMART_ALIGNMENT = \"smart\";\nconst START_ALIGNMENT = \"start\";\nconst CENTERED_ALIGNMENT = \"center\";\nconst END_ALIGNMENT = \"end\";\nconst HORIZONTAL = \"horizontal\";\nconst VERTICAL = \"vertical\";\nconst LTR = \"ltr\";\nconst RTL = \"rtl\";\nconst RTL_OFFSET_NAG = \"negative\";\nconst RTL_OFFSET_POS_ASC = \"positive-ascending\";\nconst RTL_OFFSET_POS_DESC = \"positive-descending\";\nconst DefaultListProps = {\n  cache: {\n    type: Number,\n    default: 2\n  },\n  className: {\n    type: String,\n    default: \"\"\n  },\n  containerElement: {\n    type: [String, Object],\n    default: \"div\"\n  },\n  data: {\n    type: [Array],\n    default: () => []\n  },\n  direction: {\n    type: String,\n    default: \"ltr\",\n    validator: (val) => {\n      return val === LTR || val === RTL;\n    }\n  },\n  estimatedItemSize: {\n    type: [Number]\n  },\n  height: {\n    type: [String, Number],\n    required: true\n  },\n  layout: {\n    type: String,\n    default: VERTICAL\n  },\n  initScrollOffset: {\n    type: Number,\n    default: 0\n  },\n  innerElement: {\n    type: [String, Object],\n    default: \"div\"\n  },\n  total: {\n    type: Number,\n    required: true\n  },\n  itemSize: {\n    type: [Number, Function],\n    required: true\n  },\n  style: {\n    type: [Object, String, Array],\n    default: () => ({})\n  },\n  useIsScrolling: {\n    type: Boolean,\n    default: false\n  },\n  width: {\n    type: [Number, String],\n    required: true\n  }\n};\nconst DefaultGridProps = {\n  className: DefaultListProps.className,\n  columnCache: DefaultListProps.cache,\n  columnWidth: DefaultListProps.itemSize,\n  containerElement: DefaultListProps.containerElement,\n  data: DefaultListProps.data,\n  direction: DefaultListProps.direction,\n  estimatedColumnWidth: DefaultListProps.estimatedItemSize,\n  estimatedRowHeight: DefaultListProps.estimatedItemSize,\n  height: __spreadProps(__spreadValues({}, DefaultListProps.height), {\n    validator: (val) => isNumber(val)\n  }),\n  initScrollLeft: DefaultListProps.initScrollOffset,\n  initScrollTop: DefaultListProps.initScrollOffset,\n  innerElement: DefaultListProps.innerElement,\n  rowCache: DefaultListProps.cache,\n  rowHeight: DefaultListProps.itemSize,\n  style: DefaultListProps.style,\n  useIsScrolling: DefaultListProps.useIsScrolling,\n  width: __spreadProps(__spreadValues({}, DefaultListProps.width), {\n    validator: (val) => {\n      return isNumber(val);\n    }\n  }),\n  totalColumn: DefaultListProps.total,\n  totalRow: DefaultListProps.total\n};\nconst DefaultScrollBarProps = {\n  layout: DefaultListProps.layout,\n  total: Number,\n  ratio: Number,\n  clientSize: Number,\n  scrollFrom: Number,\n  visible: Boolean\n};\nconst ScrollbarDirKey = {\n  [HORIZONTAL]: \"left\",\n  [VERTICAL]: \"top\"\n};\nconst SCROLLBAR_MIN_SIZE = 20;\n\nconst getScrollDir = (prev, cur) => prev < cur ? FORWARD : BACKWARD;\nconst isHorizontal = (dir) => dir === LTR || dir === RTL || dir === HORIZONTAL;\nconst isRTL = (dir) => dir === RTL;\nlet cachedRTLResult = null;\nfunction getRTLOffsetType(recalculate = false) {\n  if (cachedRTLResult === null || recalculate) {\n    const outerDiv = document.createElement(\"div\");\n    const outerStyle = outerDiv.style;\n    outerStyle.width = \"50px\";\n    outerStyle.height = \"50px\";\n    outerStyle.overflow = \"scroll\";\n    outerStyle.direction = \"rtl\";\n    const innerDiv = document.createElement(\"div\");\n    const innerStyle = innerDiv.style;\n    innerStyle.width = \"100px\";\n    innerStyle.height = \"100px\";\n    outerDiv.appendChild(innerDiv);\n    document.body.appendChild(outerDiv);\n    if (outerDiv.scrollLeft > 0) {\n      cachedRTLResult = RTL_OFFSET_POS_DESC;\n    } else {\n      outerDiv.scrollLeft = 1;\n      if (outerDiv.scrollLeft === 0) {\n        cachedRTLResult = RTL_OFFSET_NAG;\n      } else {\n        cachedRTLResult = RTL_OFFSET_POS_ASC;\n      }\n    }\n    document.body.removeChild(outerDiv);\n    return cachedRTLResult;\n  }\n  return cachedRTLResult;\n}\nfunction renderThumbStyle({ move, size, bar }, layout) {\n  const style = {};\n  const translate = `translate${bar.axis}(${move}px)`;\n  style[bar.size] = size;\n  style.transform = translate;\n  style.msTransform = translate;\n  style.webkitTransform = translate;\n  if (layout === \"horizontal\") {\n    style.height = \"100%\";\n  } else {\n    style.width = \"100%\";\n  }\n  return style;\n}\nconst isFF = typeof navigator !== \"undefined\" && isObject(navigator) && /Firefox/i.test(navigator.userAgent);\n\nconst LayoutKeys = {\n  [HORIZONTAL]: \"deltaX\",\n  [VERTICAL]: \"deltaY\"\n};\nconst useWheel = ({\n  atEndEdge,\n  atStartEdge,\n  layout\n}, onWheelDelta) => {\n  let frameHandle = null;\n  let offset = 0;\n  const hasReachedEdge = (offset2) => {\n    const edgeReached = offset2 < 0 && atStartEdge.value || offset2 > 0 && atEndEdge.value;\n    return edgeReached;\n  };\n  const onWheel = (e) => {\n    cAF(frameHandle);\n    const newOffset = e[LayoutKeys[layout.value]];\n    if (hasReachedEdge(offset) && hasReachedEdge(offset + newOffset))\n      return;\n    offset += newOffset;\n    if (!isFF) {\n      e.preventDefault();\n    }\n    frameHandle = rAF(() => {\n      onWheelDelta(offset);\n      offset = 0;\n    });\n  };\n  return {\n    hasReachedEdge,\n    onWheel\n  };\n};\n\nconst BAR_MAP = {\n  vertical: {\n    offset: \"offsetHeight\",\n    scroll: \"scrollTop\",\n    scrollSize: \"scrollHeight\",\n    size: \"height\",\n    key: \"vertical\",\n    axis: \"Y\",\n    client: \"clientY\",\n    direction: \"top\"\n  },\n  horizontal: {\n    offset: \"offsetWidth\",\n    scroll: \"scrollLeft\",\n    scrollSize: \"scrollWidth\",\n    size: \"width\",\n    key: \"horizontal\",\n    axis: \"X\",\n    client: \"clientX\",\n    direction: \"left\"\n  }\n};\n\nconst ScrollBar = defineComponent({\n  name: \"ElVirtualScrollBar\",\n  props: DefaultScrollBarProps,\n  emits: [\"scroll\", \"start-move\", \"stop-move\"],\n  setup(props, { emit }) {\n    const trackRef = ref(null);\n    const thumbRef = ref(null);\n    let frameHandle = null;\n    let onselectstartStore = null;\n    const state = reactive({\n      isDragging: false,\n      traveled: 0\n    });\n    const bar = computed(() => BAR_MAP[props.layout]);\n    const trackStyle = computed(() => ({\n      display: props.visible ? null : \"none\",\n      position: \"absolute\",\n      width: HORIZONTAL === props.layout ? \"100%\" : \"6px\",\n      height: HORIZONTAL === props.layout ? \"6px\" : \"100%\",\n      [ScrollbarDirKey[props.layout]]: \"2px\",\n      right: \"2px\",\n      bottom: \"2px\",\n      borderRadius: \"4px\"\n    }));\n    const thumbSize = computed(() => {\n      if (props.ratio >= 100) {\n        return Number.POSITIVE_INFINITY;\n      }\n      if (props.ratio >= 50) {\n        return props.ratio * props.clientSize / 100;\n      }\n      const SCROLLBAR_MAX_SIZE = props.clientSize / 3;\n      return Math.floor(Math.min(Math.max(props.ratio * props.clientSize, SCROLLBAR_MIN_SIZE), SCROLLBAR_MAX_SIZE));\n    });\n    const thumbStyle = computed(() => {\n      if (!Number.isFinite(thumbSize.value)) {\n        return {\n          display: \"none\"\n        };\n      }\n      const thumb = `${thumbSize.value}px`;\n      const style = renderThumbStyle({\n        bar: bar.value,\n        size: thumb,\n        move: state.traveled\n      }, props.layout);\n      return style;\n    });\n    const totalSteps = computed(() => Math.floor(props.clientSize - thumbSize.value - 4));\n    const attachEvents = () => {\n      on(window, \"mousemove\", onMouseMove);\n      on(window, \"mouseup\", onMouseUp);\n      const thumbEl = thumbRef.value;\n      onselectstartStore = document.onselectstart;\n      document.onselectstart = () => false;\n      on(thumbEl, \"touchmove\", onMouseMove);\n      on(thumbEl, \"touchend\", onMouseUp);\n    };\n    const detachEvents = () => {\n      off(window, \"mousemove\", onMouseMove);\n      off(window, \"mouseup\", onMouseUp);\n      document.onselectstart = onselectstartStore;\n      onselectstartStore = null;\n      const thumbEl = thumbRef.value;\n      off(thumbEl, \"touchmove\", onMouseMove);\n      off(thumbEl, \"touchend\", onMouseUp);\n    };\n    const onThumbMouseDown = (e) => {\n      e.stopImmediatePropagation();\n      if (e.ctrlKey || [1, 2].includes(e.button)) {\n        return;\n      }\n      state.isDragging = true;\n      state[bar.value.axis] = e.currentTarget[bar.value.offset] - (e[bar.value.client] - e.currentTarget.getBoundingClientRect()[bar.value.direction]);\n      emit(\"start-move\");\n      attachEvents();\n    };\n    const onMouseUp = () => {\n      state.isDragging = false;\n      state[bar.value.axis] = 0;\n      emit(\"stop-move\");\n      detachEvents();\n    };\n    const onMouseMove = (e) => {\n      const { isDragging } = state;\n      if (!isDragging)\n        return;\n      const prevPage = state[bar.value.axis];\n      if (!prevPage)\n        return;\n      cAF(frameHandle);\n      const offset = (trackRef.value.getBoundingClientRect()[bar.value.direction] - e[bar.value.client]) * -1;\n      const thumbClickPosition = thumbRef.value[bar.value.offset] - prevPage;\n      const distance = offset - thumbClickPosition;\n      frameHandle = rAF(() => {\n        state.traveled = Math.max(2, Math.min(distance, totalSteps.value));\n        emit(\"scroll\", distance, totalSteps.value);\n      });\n    };\n    const onScrollbarTouchStart = (e) => e.preventDefault();\n    watch(() => props.scrollFrom, (v) => {\n      if (state.isDragging)\n        return;\n      state.traveled = Math.ceil(v * props.clientSize / (props.clientSize / totalSteps.value));\n    });\n    onMounted(() => {\n      if (isServer)\n        return;\n      on(trackRef.value, \"touchstart\", onScrollbarTouchStart);\n      on(thumbRef.value, \"touchstart\", onThumbMouseDown);\n    });\n    onBeforeUnmount(() => {\n      off(trackRef.value, \"touchstart\", onScrollbarTouchStart);\n      detachEvents();\n    });\n    return () => {\n      return h(\"div\", {\n        role: \"presentation\",\n        ref: trackRef,\n        class: \"el-virtual-scrollbar\",\n        style: trackStyle.value,\n        onMousedown: withModifiers(NOOP, [\"stop\", \"prevent\"])\n      }, h(\"div\", {\n        ref: thumbRef,\n        class: \"el-scrollbar__thumb\",\n        style: thumbStyle.value,\n        onMousedown: onThumbMouseDown\n      }, null));\n    };\n  }\n});\n\nvar __defProp$1 = Object.defineProperty;\nvar __defProps$1 = Object.defineProperties;\nvar __getOwnPropDescs$1 = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols$1 = Object.getOwnPropertySymbols;\nvar __hasOwnProp$1 = Object.prototype.hasOwnProperty;\nvar __propIsEnum$1 = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$1 = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$1.call(b, prop))\n      __defNormalProp$1(a, prop, b[prop]);\n  if (__getOwnPropSymbols$1)\n    for (var prop of __getOwnPropSymbols$1(b)) {\n      if (__propIsEnum$1.call(b, prop))\n        __defNormalProp$1(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps$1 = (a, b) => __defProps$1(a, __getOwnPropDescs$1(b));\nconst createList = ({\n  name,\n  getOffset,\n  getItemSize,\n  getItemOffset,\n  getEstimatedTotalSize,\n  getStartIndexForOffset,\n  getStopIndexForStartIndex,\n  initCache,\n  clearCache,\n  validateProps\n}) => {\n  return defineComponent({\n    name: name != null ? name : \"ElVirtualList\",\n    props: DefaultListProps,\n    emits: [ITEM_RENDER_EVT, SCROLL_EVT],\n    setup(props, { emit, expose }) {\n      validateProps(props);\n      const instance = getCurrentInstance();\n      const dynamicSizeCache = ref(initCache(props, instance));\n      const windowRef = ref(null);\n      const innerRef = ref(null);\n      const scrollbarRef = ref(null);\n      const states = ref({\n        isScrolling: false,\n        scrollDir: \"forward\",\n        scrollOffset: isNumber(props.initScrollOffset) ? props.initScrollOffset : 0,\n        updateRequested: false,\n        isScrollbarDragging: false\n      });\n      const itemsToRender = computed(() => {\n        const { total, cache } = props;\n        const { isScrolling, scrollDir, scrollOffset } = $(states);\n        if (total === 0) {\n          return [0, 0, 0, 0];\n        }\n        const startIndex = getStartIndexForOffset(props, scrollOffset, $(dynamicSizeCache));\n        const stopIndex = getStopIndexForStartIndex(props, startIndex, scrollOffset, $(dynamicSizeCache));\n        const cacheBackward = !isScrolling || scrollDir === BACKWARD ? Math.max(1, cache) : 1;\n        const cacheForward = !isScrolling || scrollDir === FORWARD ? Math.max(1, cache) : 1;\n        return [\n          Math.max(0, startIndex - cacheBackward),\n          Math.max(0, Math.min(total - 1, stopIndex + cacheForward)),\n          startIndex,\n          stopIndex\n        ];\n      });\n      const estimatedTotalSize = computed(() => getEstimatedTotalSize(props, $(dynamicSizeCache)));\n      const _isHorizontal = computed(() => isHorizontal(props.layout));\n      const windowStyle = computed(() => [\n        {\n          position: \"relative\",\n          overflow: \"hidden\",\n          WebkitOverflowScrolling: \"touch\",\n          willChange: \"transform\"\n        },\n        __spreadValues$1({\n          direction: props.direction,\n          height: isNumber(props.height) ? `${props.height}px` : props.height,\n          width: isNumber(props.width) ? `${props.width}px` : props.width\n        }, props.style)\n      ]);\n      const innerStyle = computed(() => {\n        const size = $(estimatedTotalSize);\n        const horizontal = $(_isHorizontal);\n        return {\n          height: horizontal ? \"100%\" : `${size}px`,\n          pointerEvents: $(states).isScrolling ? \"none\" : void 0,\n          width: horizontal ? `${size}px` : \"100%\"\n        };\n      });\n      const clientSize = computed(() => _isHorizontal.value ? props.width : props.height);\n      const {\n        onWheel\n      } = useWheel({\n        atStartEdge: computed(() => states.value.scrollOffset <= 0),\n        atEndEdge: computed(() => states.value.scrollOffset >= estimatedTotalSize.value),\n        layout: computed(() => props.layout)\n      }, (offset) => {\n        var _a, _b;\n        (_b = (_a = scrollbarRef.value).onMouseUp) == null ? void 0 : _b.call(_a);\n        scrollTo(Math.min(states.value.scrollOffset + offset, estimatedTotalSize.value - clientSize.value));\n      });\n      const emitEvents = () => {\n        const { total } = props;\n        if (total > 0) {\n          const [cacheStart, cacheEnd, visibleStart, visibleEnd] = $(itemsToRender);\n          emit(ITEM_RENDER_EVT, cacheStart, cacheEnd, visibleStart, visibleEnd);\n        }\n        const { scrollDir, scrollOffset, updateRequested } = $(states);\n        emit(SCROLL_EVT, scrollDir, scrollOffset, updateRequested);\n      };\n      const scrollVertically = (e) => {\n        const { clientHeight, scrollHeight, scrollTop } = e.currentTarget;\n        const _states = $(states);\n        if (_states.scrollOffset === scrollTop) {\n          return;\n        }\n        const scrollOffset = Math.max(0, Math.min(scrollTop, scrollHeight - clientHeight));\n        states.value = __spreadProps$1(__spreadValues$1({}, _states), {\n          isScrolling: true,\n          scrollDir: getScrollDir(_states.scrollOffset, scrollOffset),\n          scrollOffset,\n          updateRequested: false\n        });\n        nextTick(resetIsScrolling);\n      };\n      const scrollHorizontally = (e) => {\n        const { clientWidth, scrollLeft, scrollWidth } = e.currentTarget;\n        const _states = $(states);\n        if (_states.scrollOffset === scrollLeft) {\n          return;\n        }\n        const { direction } = props;\n        let scrollOffset = scrollLeft;\n        if (direction === RTL) {\n          switch (getRTLOffsetType()) {\n            case RTL_OFFSET_NAG: {\n              scrollOffset = -scrollLeft;\n              break;\n            }\n            case RTL_OFFSET_POS_DESC: {\n              scrollOffset = scrollWidth - clientWidth - scrollLeft;\n              break;\n            }\n          }\n        }\n        scrollOffset = Math.max(0, Math.min(scrollOffset, scrollWidth - clientWidth));\n        states.value = __spreadProps$1(__spreadValues$1({}, _states), {\n          isScrolling: true,\n          scrollDir: getScrollDir(_states.scrollOffset, scrollOffset),\n          scrollOffset,\n          updateRequested: false\n        });\n        nextTick(resetIsScrolling);\n      };\n      const onScroll = (e) => {\n        $(_isHorizontal) ? scrollHorizontally(e) : scrollVertically(e);\n        emitEvents();\n      };\n      const onScrollbarScroll = (distanceToGo, totalSteps) => {\n        const offset = (estimatedTotalSize.value - clientSize.value) / totalSteps * distanceToGo;\n        scrollTo(Math.min(estimatedTotalSize.value - clientSize.value, offset));\n      };\n      const getItemStyleCache = memo((_, __, ___) => ({}));\n      const scrollTo = (offset) => {\n        offset = Math.max(offset, 0);\n        if (offset === $(states).scrollOffset) {\n          return;\n        }\n        states.value = __spreadProps$1(__spreadValues$1({}, $(states)), {\n          scrollOffset: offset,\n          scrollDir: getScrollDir($(states).scrollOffset, offset),\n          updateRequested: true\n        });\n        nextTick(resetIsScrolling);\n      };\n      const scrollToItem = (idx, alignment = AUTO_ALIGNMENT) => {\n        const { scrollOffset } = $(states);\n        idx = Math.max(0, Math.min(idx, props.total - 1));\n        scrollTo(getOffset(props, idx, alignment, scrollOffset, $(dynamicSizeCache)));\n      };\n      const getItemStyle = (idx) => {\n        const { direction, itemSize, layout } = props;\n        const itemStyleCache = getItemStyleCache(clearCache && itemSize, clearCache && layout, clearCache && direction);\n        let style;\n        if (hasOwn(itemStyleCache, String(idx))) {\n          style = itemStyleCache[idx];\n        } else {\n          const offset = getItemOffset(props, idx, $(dynamicSizeCache));\n          const size = getItemSize(props, idx, $(dynamicSizeCache));\n          const horizontal = $(_isHorizontal);\n          const isRtl = direction === RTL;\n          const offsetHorizontal = horizontal ? offset : 0;\n          itemStyleCache[idx] = style = {\n            position: \"absolute\",\n            left: isRtl ? void 0 : `${offsetHorizontal}px`,\n            right: isRtl ? `${offsetHorizontal}px` : void 0,\n            top: !horizontal ? `${offset}px` : 0,\n            height: !horizontal ? `${size}px` : \"100%\",\n            width: horizontal ? `${size}px` : \"100%\"\n          };\n        }\n        return style;\n      };\n      const resetIsScrolling = () => {\n        states.value.isScrolling = false;\n        nextTick(() => {\n          getItemStyleCache(-1, null, null);\n        });\n      };\n      onMounted(() => {\n        if (isServer)\n          return;\n        const { initScrollOffset } = props;\n        const windowElement = $(windowRef);\n        if (isNumber(initScrollOffset) && windowElement !== null) {\n          if ($(_isHorizontal)) {\n            windowElement.scrollLeft = initScrollOffset;\n          } else {\n            windowElement.scrollTop = initScrollOffset;\n          }\n        }\n        emitEvents();\n      });\n      onUpdated(() => {\n        const { direction, layout } = props;\n        const { scrollOffset, updateRequested } = $(states);\n        if (updateRequested && $(windowRef) !== null) {\n          const windowElement = $(windowRef);\n          if (layout === HORIZONTAL) {\n            if (direction === RTL) {\n              switch (getRTLOffsetType()) {\n                case \"negative\": {\n                  windowElement.scrollLeft = -scrollOffset;\n                  break;\n                }\n                case \"positive-ascending\": {\n                  windowElement.scrollLeft = scrollOffset;\n                  break;\n                }\n                default: {\n                  const { clientWidth, scrollWidth } = windowElement;\n                  windowElement.scrollLeft = scrollWidth - clientWidth - scrollOffset;\n                  break;\n                }\n              }\n            } else {\n              windowElement.scrollLeft = scrollOffset;\n            }\n          } else {\n            windowElement.scrollTop = scrollOffset;\n          }\n        }\n      });\n      const api = {\n        clientSize,\n        estimatedTotalSize,\n        windowStyle,\n        windowRef,\n        innerRef,\n        innerStyle,\n        itemsToRender,\n        scrollbarRef,\n        states,\n        getItemStyle,\n        onScroll,\n        onScrollbarScroll,\n        onWheel,\n        scrollTo,\n        scrollToItem\n      };\n      expose({\n        windowRef,\n        innerRef,\n        getItemStyleCache,\n        scrollTo,\n        scrollToItem,\n        states\n      });\n      return api;\n    },\n    render(ctx) {\n      var _a;\n      const {\n        $slots,\n        className,\n        clientSize,\n        containerElement,\n        data,\n        getItemStyle,\n        innerElement,\n        itemsToRender,\n        innerStyle,\n        layout,\n        total,\n        onScroll,\n        onScrollbarScroll,\n        onWheel,\n        states,\n        useIsScrolling,\n        windowStyle\n      } = ctx;\n      const [start, end] = itemsToRender;\n      const Container = resolveDynamicComponent(containerElement);\n      const Inner = resolveDynamicComponent(innerElement);\n      const children = [];\n      if (total > 0) {\n        for (let i = start; i <= end; i++) {\n          children.push((_a = $slots.default) == null ? void 0 : _a.call($slots, {\n            data,\n            key: i,\n            index: i,\n            isScrolling: useIsScrolling ? states.isScrolling : void 0,\n            style: getItemStyle(i)\n          }));\n        }\n      }\n      const InnerNode = [h(Inner, {\n        style: innerStyle,\n        ref: \"innerRef\"\n      }, !isString(Inner) ? {\n        default: () => children\n      } : children)];\n      const scrollbar = h(ScrollBar, {\n        ref: \"scrollbarRef\",\n        clientSize,\n        layout,\n        onScroll: onScrollbarScroll,\n        ratio: clientSize * 100 / this.estimatedTotalSize,\n        scrollFrom: states.scrollOffset / (this.estimatedTotalSize - clientSize),\n        total,\n        visible: true\n      });\n      const listContainer = h(Container, {\n        class: className,\n        style: windowStyle,\n        onScroll,\n        onWheel,\n        ref: \"windowRef\",\n        key: 0\n      }, !isString(Container) ? { default: () => [InnerNode] } : [InnerNode]);\n      return h(\"div\", {\n        key: 0,\n        class: \"el-vl__wrapper\"\n      }, [\n        listContainer,\n        scrollbar\n      ]);\n    }\n  });\n};\n\nconst FixedSizeList = createList({\n  name: \"ElFixedSizeList\",\n  getItemOffset: ({ itemSize }, index) => index * itemSize,\n  getItemSize: ({ itemSize }) => itemSize,\n  getEstimatedTotalSize: ({ total, itemSize }) => itemSize * total,\n  getOffset: ({ height, total, itemSize, layout, width }, index, alignment, scrollOffset) => {\n    const size = isHorizontal(layout) ? width : height;\n    if (process.env.ENV !== \"production\" && isString(size)) {\n      throwError(\"[ElVirtualList]\", `\n        You should set\n          width/height\n        to number when your layout is\n          horizontal/vertical\n      `);\n    }\n    const lastItemOffset = Math.max(0, total * itemSize - size);\n    const maxOffset = Math.min(lastItemOffset, index * itemSize);\n    const minOffset = Math.max(0, (index + 1) * itemSize - size);\n    if (alignment === SMART_ALIGNMENT) {\n      if (scrollOffset >= minOffset - size && scrollOffset <= maxOffset + size) {\n        alignment = AUTO_ALIGNMENT;\n      } else {\n        alignment = CENTERED_ALIGNMENT;\n      }\n    }\n    switch (alignment) {\n      case START_ALIGNMENT: {\n        return maxOffset;\n      }\n      case END_ALIGNMENT: {\n        return minOffset;\n      }\n      case CENTERED_ALIGNMENT: {\n        const middleOffset = Math.round(minOffset + (maxOffset - minOffset) / 2);\n        if (middleOffset < Math.ceil(size / 2)) {\n          return 0;\n        } else if (middleOffset > lastItemOffset + Math.floor(size / 2)) {\n          return lastItemOffset;\n        } else {\n          return middleOffset;\n        }\n      }\n      case AUTO_ALIGNMENT:\n      default: {\n        if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {\n          return scrollOffset;\n        } else if (scrollOffset < minOffset) {\n          return minOffset;\n        } else {\n          return maxOffset;\n        }\n      }\n    }\n  },\n  getStartIndexForOffset: ({ total, itemSize }, offset) => Math.max(0, Math.min(total - 1, Math.floor(offset / itemSize))),\n  getStopIndexForStartIndex: ({ height, total, itemSize, layout, width }, startIndex, scrollOffset) => {\n    const offset = startIndex * itemSize;\n    const size = isHorizontal(layout) ? width : height;\n    const numVisibleItems = Math.ceil((size + scrollOffset - offset) / itemSize);\n    return Math.max(0, Math.min(total - 1, startIndex + numVisibleItems - 1));\n  },\n  initCache() {\n    return void 0;\n  },\n  clearCache: true,\n  validateProps() {\n  }\n});\n\nconst SCOPE = \"ElDynamicSizeList\";\nconst getItemFromCache = (props, index, listCache) => {\n  const { itemSize } = props;\n  const { items, lastVisitedIndex } = listCache;\n  if (index > lastVisitedIndex) {\n    let offset = 0;\n    if (lastVisitedIndex >= 0) {\n      const item = items[lastVisitedIndex];\n      offset = item.offset + item.size;\n    }\n    for (let i = lastVisitedIndex + 1; i <= index; i++) {\n      const size = itemSize(i);\n      items[i] = {\n        offset,\n        size\n      };\n      offset += size;\n    }\n    listCache.lastVisitedIndex = index;\n  }\n  return items[index];\n};\nconst findItem = (props, listCache, offset) => {\n  const { items, lastVisitedIndex } = listCache;\n  const lastVisitedOffset = lastVisitedIndex > 0 ? items[lastVisitedIndex].offset : 0;\n  if (lastVisitedOffset >= offset) {\n    return bs(props, listCache, 0, lastVisitedIndex, offset);\n  }\n  return es(props, listCache, Math.max(0, lastVisitedIndex), offset);\n};\nconst bs = (props, listCache, low, high, offset) => {\n  while (low <= high) {\n    const mid = low + Math.floor((high - low) / 2);\n    const currentOffset = getItemFromCache(props, mid, listCache).offset;\n    if (currentOffset === offset) {\n      return mid;\n    } else if (currentOffset < offset) {\n      low = mid + 1;\n    } else if (currentOffset > offset) {\n      high = mid - 1;\n    }\n  }\n  return Math.max(0, low - 1);\n};\nconst es = (props, listCache, index, offset) => {\n  const { total } = props;\n  let exponent = 1;\n  while (index < total && getItemFromCache(props, index, listCache).offset < offset) {\n    index += exponent;\n    exponent *= 2;\n  }\n  return bs(props, listCache, Math.floor(index / 2), Math.min(index, total - 1), offset);\n};\nconst getEstimatedTotalSize = ({ total }, { items, estimatedItemSize, lastVisitedIndex }) => {\n  let totalSizeOfMeasuredItems = 0;\n  if (lastVisitedIndex >= total) {\n    lastVisitedIndex = total - 1;\n  }\n  if (lastVisitedIndex >= 0) {\n    const item = items[lastVisitedIndex];\n    totalSizeOfMeasuredItems = item.offset + item.size;\n  }\n  const numUnmeasuredItems = total - lastVisitedIndex - 1;\n  const totalSizeOfUnmeasuredItems = numUnmeasuredItems * estimatedItemSize;\n  return totalSizeOfMeasuredItems + totalSizeOfUnmeasuredItems;\n};\nconst DynamicSizeList = createList({\n  name: \"ElDynamicSizeList\",\n  getItemOffset: (props, index, listCache) => getItemFromCache(props, index, listCache).offset,\n  getItemSize: (_, index, { items }) => items[index].size,\n  getEstimatedTotalSize,\n  getOffset: (props, index, alignment, scrollOffset, listCache) => {\n    const { height, layout, width } = props;\n    const size = isHorizontal(layout) ? width : height;\n    const item = getItemFromCache(props, index, listCache);\n    const estimatedTotalSize = getEstimatedTotalSize(props, listCache);\n    const maxOffset = Math.max(0, Math.min(estimatedTotalSize - size, item.offset));\n    const minOffset = Math.max(0, item.offset - size + item.size);\n    if (alignment === SMART_ALIGNMENT) {\n      if (scrollOffset >= minOffset - size && scrollOffset <= maxOffset + size) {\n        alignment = AUTO_ALIGNMENT;\n      } else {\n        alignment = CENTERED_ALIGNMENT;\n      }\n    }\n    switch (alignment) {\n      case START_ALIGNMENT: {\n        return maxOffset;\n      }\n      case END_ALIGNMENT: {\n        return minOffset;\n      }\n      case CENTERED_ALIGNMENT: {\n        return Math.round(minOffset + (maxOffset - minOffset) / 2);\n      }\n      case AUTO_ALIGNMENT:\n      default: {\n        if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {\n          return scrollOffset;\n        } else if (scrollOffset < minOffset) {\n          return minOffset;\n        } else {\n          return maxOffset;\n        }\n      }\n    }\n  },\n  getStartIndexForOffset: (props, offset, listCache) => findItem(props, listCache, offset),\n  getStopIndexForStartIndex: (props, startIndex, scrollOffset, listCache) => {\n    const { height, total, layout, width } = props;\n    const size = isHorizontal(layout) ? width : height;\n    const item = getItemFromCache(props, startIndex, listCache);\n    const maxOffset = scrollOffset + size;\n    let offset = item.offset + item.size;\n    let stopIndex = startIndex;\n    while (stopIndex < total - 1 && offset < maxOffset) {\n      stopIndex++;\n      offset += getItemFromCache(props, stopIndex, listCache).size;\n    }\n    return stopIndex;\n  },\n  initCache({ estimatedItemSize = DEFAULT_DYNAMIC_LIST_ITEM_SIZE }, instance) {\n    const cache = {\n      items: {},\n      estimatedItemSize,\n      lastVisitedIndex: -1\n    };\n    cache.clearCacheAfterIndex = (index, forceUpdate = true) => {\n      cache.lastVisitedIndex = Math.min(cache.lastVisitedIndex, index - 1);\n      instance.exposed.getItemStyleCache(-1);\n      if (forceUpdate) {\n        instance.proxy.$forceUpdate();\n      }\n    };\n    return cache;\n  },\n  clearCache: false,\n  validateProps: ({ itemSize }) => {\n    if (process.env.NODE_ENV !== \"production\") {\n      if (typeof itemSize !== \"function\") {\n        throwError(SCOPE, `\n          itemSize is required as function, but the given value was ${typeof itemSize}\n        `);\n      }\n    }\n  }\n});\n\nvar __defProp$2 = Object.defineProperty;\nvar __defProps$2 = Object.defineProperties;\nvar __getOwnPropDescs$2 = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols$2 = Object.getOwnPropertySymbols;\nvar __hasOwnProp$2 = Object.prototype.hasOwnProperty;\nvar __propIsEnum$2 = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$2 = (obj, key, value) => key in obj ? __defProp$2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$2 = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$2.call(b, prop))\n      __defNormalProp$2(a, prop, b[prop]);\n  if (__getOwnPropSymbols$2)\n    for (var prop of __getOwnPropSymbols$2(b)) {\n      if (__propIsEnum$2.call(b, prop))\n        __defNormalProp$2(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps$2 = (a, b) => __defProps$2(a, __getOwnPropDescs$2(b));\nconst createGrid = ({\n  name,\n  clearCache,\n  getColumnPosition,\n  getColumnStartIndexForOffset,\n  getColumnStopIndexForStartIndex,\n  getEstimatedTotalHeight,\n  getEstimatedTotalWidth,\n  getColumnOffset,\n  getRowOffset,\n  getRowPosition,\n  getRowStartIndexForOffset,\n  getRowStopIndexForStartIndex,\n  initCache,\n  validateProps\n}) => {\n  return defineComponent({\n    name: name != null ? name : \"ElVirtualList\",\n    props: DefaultGridProps,\n    emits: [ITEM_RENDER_EVT, SCROLL_EVT],\n    setup(props, { emit, expose }) {\n      validateProps(props);\n      const instance = getCurrentInstance();\n      const cache = ref(initCache(props, instance));\n      const windowRef = ref(null);\n      const innerRef = ref(null);\n      const states = ref({\n        isScrolling: false,\n        scrollLeft: isNumber(props.initScrollLeft) ? props.initScrollLeft : 0,\n        scrollTop: isNumber(props.initScrollTop) ? props.initScrollTop : 0,\n        updateRequested: false,\n        xAxisScrollDir: FORWARD,\n        yAxisScrollDir: FORWARD\n      });\n      const columnsToRender = computed(() => {\n        const { totalColumn, totalRow, columnCache } = props;\n        const { isScrolling, xAxisScrollDir, scrollLeft } = $(states);\n        if (totalColumn === 0 || totalRow === 0) {\n          return [0, 0, 0, 0];\n        }\n        const startIndex = getColumnStartIndexForOffset(props, scrollLeft, $(cache));\n        const stopIndex = getColumnStopIndexForStartIndex(props, startIndex, scrollLeft, $(cache));\n        const cacheBackward = !isScrolling || xAxisScrollDir === BACKWARD ? Math.max(1, columnCache) : 1;\n        const cacheForward = !isScrolling || xAxisScrollDir === FORWARD ? Math.max(1, columnCache) : 1;\n        return [\n          Math.max(0, startIndex - cacheBackward),\n          Math.max(0, Math.min(totalColumn - 1, stopIndex + cacheForward)),\n          startIndex,\n          stopIndex\n        ];\n      });\n      const rowsToRender = computed(() => {\n        const { totalColumn, totalRow, rowCache } = props;\n        const { isScrolling, yAxisScrollDir, scrollTop } = $(states);\n        if (totalColumn === 0 || totalRow === 0) {\n          return [0, 0, 0, 0];\n        }\n        const startIndex = getRowStartIndexForOffset(props, scrollTop, $(cache));\n        const stopIndex = getRowStopIndexForStartIndex(props, startIndex, scrollTop, $(cache));\n        const cacheBackward = !isScrolling || yAxisScrollDir === BACKWARD ? Math.max(1, rowCache) : 1;\n        const cacheForward = !isScrolling || yAxisScrollDir === FORWARD ? Math.max(1, rowCache) : 1;\n        return [\n          Math.max(0, startIndex - cacheBackward),\n          Math.max(0, Math.min(totalRow - 1, stopIndex + cacheForward)),\n          startIndex,\n          stopIndex\n        ];\n      });\n      const estimatedTotalHeight = computed(() => getEstimatedTotalHeight(props, $(cache)));\n      const estimatedTotalWidth = computed(() => getEstimatedTotalWidth(props, $(cache)));\n      const windowStyle = computed(() => [\n        {\n          position: \"relative\",\n          overflow: \"auto\",\n          WebkitOverflowScrolling: \"touch\",\n          willChange: \"transform\"\n        },\n        __spreadValues$2({\n          direction: props.direction,\n          height: isNumber(props.height) ? `${props.height}px` : props.height,\n          width: isNumber(props.width) ? `${props.width}px` : props.width\n        }, props.style)\n      ]);\n      const innerStyle = computed(() => {\n        const width = `${$(estimatedTotalWidth)}px`;\n        const height = `${$(estimatedTotalHeight)}px`;\n        return {\n          height,\n          pointerEvents: $(states).isScrolling ? \"none\" : void 0,\n          width\n        };\n      });\n      const emitEvents = () => {\n        const { totalColumn, totalRow } = props;\n        if (totalColumn > 0 && totalRow > 0) {\n          const [columnCacheStart, columnCacheEnd, columnVisibleStart, columnVisibleEnd] = $(columnsToRender);\n          const [rowCacheStart, rowCacheEnd, rowVisibleStart, rowVisibleEnd] = $(rowsToRender);\n          emit(ITEM_RENDER_EVT, columnCacheStart, columnCacheEnd, rowCacheStart, rowCacheEnd, columnVisibleStart, columnVisibleEnd, rowVisibleStart, rowVisibleEnd);\n        }\n        const { scrollLeft, scrollTop, updateRequested, xAxisScrollDir, yAxisScrollDir } = $(states);\n        emit(SCROLL_EVT, xAxisScrollDir, scrollLeft, yAxisScrollDir, scrollTop, updateRequested);\n      };\n      const onScroll = (e) => {\n        const {\n          clientHeight,\n          clientWidth,\n          scrollHeight,\n          scrollLeft,\n          scrollTop,\n          scrollWidth\n        } = e.currentTarget;\n        const _states = $(states);\n        if (_states.scrollTop === scrollTop && _states.scrollLeft === scrollLeft) {\n          return;\n        }\n        let _scrollLeft = scrollLeft;\n        if (isRTL(props.direction)) {\n          switch (getRTLOffsetType()) {\n            case RTL_OFFSET_NAG:\n              _scrollLeft = -scrollLeft;\n              break;\n            case RTL_OFFSET_POS_DESC:\n              _scrollLeft = scrollWidth - clientWidth - scrollLeft;\n              break;\n          }\n        }\n        states.value = __spreadProps$2(__spreadValues$2({}, _states), {\n          isScrolling: true,\n          scrollLeft: _scrollLeft,\n          scrollTop: Math.max(0, Math.min(scrollTop, scrollHeight - clientHeight)),\n          updateRequested: false,\n          xAxisScrollDir: getScrollDir(_states.scrollLeft, _scrollLeft),\n          yAxisScrollDir: getScrollDir(_states.scrollTop, scrollTop)\n        });\n        nextTick(resetIsScrolling);\n        emitEvents();\n      };\n      const getItemStyleCache = memo((_, __, ___) => ({}));\n      const scrollTo = ({\n        scrollLeft,\n        scrollTop\n      }) => {\n        scrollLeft = Math.max(scrollLeft, 0);\n        scrollTop = Math.max(scrollTop, 0);\n        const _states = $(states);\n        if (scrollTop === _states.scrollTop && scrollLeft === _states.scrollLeft) {\n          return;\n        }\n        states.value = __spreadProps$2(__spreadValues$2({}, _states), {\n          xAxisScrollDir: getScrollDir(_states.scrollLeft, scrollLeft),\n          yAxisScrollDir: getScrollDir(_states.scrollTop, scrollTop),\n          scrollLeft,\n          scrollTop,\n          updateRequested: true\n        });\n        nextTick(resetIsScrolling);\n      };\n      const scrollToItem = (rowIndex = 0, columnIdx = 0, alignment = AUTO_ALIGNMENT) => {\n        const _states = $(states);\n        columnIdx = Math.max(0, Math.min(columnIdx, props.totalColumn - 1));\n        rowIndex = Math.max(0, Math.min(rowIndex, props.totalRow - 1));\n        const scrollBarWidth = getScrollBarWidth();\n        const _cache = $(cache);\n        const estimatedHeight = getEstimatedTotalHeight(props, _cache);\n        const estimatedWidth = getEstimatedTotalWidth(props, _cache);\n        scrollTo({\n          scrollLeft: getColumnOffset(props, columnIdx, alignment, _states.scrollLeft, _cache, estimatedWidth > props.width ? scrollBarWidth : 0),\n          scrollTop: getRowOffset(props, rowIndex, alignment, _states.scrollTop, _cache, estimatedHeight > props.height ? scrollBarWidth : 0)\n        });\n      };\n      const getItemStyle = (rowIndex, columnIndex) => {\n        const { columnWidth, direction, rowHeight } = props;\n        const itemStyleCache = getItemStyleCache(clearCache && columnWidth, clearCache && rowHeight, clearCache && direction);\n        const key = `${rowIndex},${columnIndex}`;\n        if (hasOwn(itemStyleCache, key)) {\n          return itemStyleCache[key];\n        } else {\n          const [, left] = getColumnPosition(props, columnIndex, $(cache));\n          const _cache = $(cache);\n          const rtl = isRTL(direction);\n          const [height, top] = getRowPosition(props, rowIndex, _cache);\n          const [width] = getColumnPosition(props, columnIndex, _cache);\n          itemStyleCache[key] = {\n            position: \"absolute\",\n            left: rtl ? void 0 : `${left}px`,\n            right: rtl ? `${left}px` : void 0,\n            top: `${top}px`,\n            height: `${height}px`,\n            width: `${width}px`\n          };\n          return itemStyleCache[key];\n        }\n      };\n      const resetIsScrolling = () => {\n        states.value.isScrolling = false;\n        nextTick(() => {\n          getItemStyleCache(-1, null, null);\n        });\n      };\n      onMounted(() => {\n        if (isServer)\n          return;\n        const { initScrollLeft, initScrollTop } = props;\n        const windowElement = $(windowRef);\n        if (windowElement !== null) {\n          if (isNumber(initScrollLeft)) {\n            windowElement.scrollLeft = initScrollLeft;\n          }\n          if (isNumber(initScrollTop)) {\n            windowElement.scrollTop = initScrollTop;\n          }\n        }\n        emitEvents();\n      });\n      onUpdated(() => {\n        const { direction } = props;\n        const { scrollLeft, scrollTop, updateRequested } = $(states);\n        if (updateRequested && $(windowRef) !== null) {\n          const windowElement = $(windowRef);\n          if (direction === RTL) {\n            switch (getRTLOffsetType()) {\n              case RTL_OFFSET_NAG: {\n                windowElement.scrollLeft = -scrollLeft;\n                break;\n              }\n              case RTL_OFFSET_POS_ASC: {\n                windowElement.scrollLeft = scrollLeft;\n                break;\n              }\n              default: {\n                const { clientWidth, scrollWidth } = windowElement;\n                windowElement.scrollLeft = scrollWidth - clientWidth - scrollLeft;\n                break;\n              }\n            }\n          } else {\n            windowElement.scrollLeft = Math.max(0, scrollLeft);\n          }\n          windowElement.scrollTop = Math.max(0, scrollTop);\n        }\n      });\n      const api = {\n        windowStyle,\n        windowRef,\n        columnsToRender,\n        innerRef,\n        innerStyle,\n        states,\n        rowsToRender,\n        getItemStyle,\n        onScroll,\n        scrollTo,\n        scrollToItem\n      };\n      expose({\n        windowRef,\n        innerRef,\n        getItemStyleCache,\n        scrollTo,\n        scrollToItem,\n        states\n      });\n      return api;\n    },\n    render(ctx) {\n      var _a;\n      const {\n        $slots,\n        className,\n        containerElement,\n        columnsToRender,\n        data,\n        getItemStyle,\n        innerElement,\n        innerStyle,\n        rowsToRender,\n        onScroll,\n        states,\n        useIsScrolling,\n        windowStyle,\n        totalColumn,\n        totalRow\n      } = ctx;\n      const [columnStart, columnEnd] = columnsToRender;\n      const [rowStart, rowEnd] = rowsToRender;\n      const Container = resolveDynamicComponent(containerElement);\n      const Inner = resolveDynamicComponent(innerElement);\n      const children = [];\n      if (totalRow > 0 && totalColumn > 0) {\n        for (let row = rowStart; row <= rowEnd; row++) {\n          for (let column = columnStart; column <= columnEnd; column++) {\n            children.push((_a = $slots.default) == null ? void 0 : _a.call($slots, {\n              columnIndex: column,\n              data,\n              key: column,\n              isScrolling: useIsScrolling ? states.isScrolling : void 0,\n              style: getItemStyle(row, column),\n              rowIndex: row\n            }));\n          }\n        }\n      }\n      const InnerNode = [h(Inner, {\n        style: innerStyle,\n        ref: \"innerRef\"\n      }, !isString(Inner) ? {\n        default: () => children\n      } : children)];\n      return h(Container, {\n        class: className,\n        style: windowStyle,\n        onScroll,\n        ref: \"windowRef\"\n      }, !isString(Container) ? { default: () => InnerNode } : InnerNode);\n    }\n  });\n};\n\nconst SCOPE$1 = \"ElFixedSizeGrid\";\nconst FixedSizeGrid = createGrid({\n  name: \"ElFixedSizeGrid\",\n  getColumnPosition: ({ columnWidth }, index) => [\n    columnWidth,\n    index * columnWidth\n  ],\n  getRowPosition: ({ rowHeight }, index) => [\n    rowHeight,\n    index * rowHeight\n  ],\n  getEstimatedTotalHeight: ({ totalRow, rowHeight }) => rowHeight * totalRow,\n  getEstimatedTotalWidth: ({ totalColumn, columnWidth }) => columnWidth * totalColumn,\n  getColumnOffset: ({ totalColumn, columnWidth, width }, columnIndex, alignment, scrollLeft, _, scrollBarWidth) => {\n    width = Number(width);\n    const lastColumnOffset = Math.max(0, totalColumn * columnWidth - width);\n    const maxOffset = Math.min(lastColumnOffset, columnIndex * columnWidth);\n    const minOffset = Math.max(0, columnIndex * columnWidth - width + scrollBarWidth + columnWidth);\n    if (alignment === \"smart\") {\n      if (scrollLeft >= minOffset - width && scrollLeft <= maxOffset + width) {\n        alignment = AUTO_ALIGNMENT;\n      } else {\n        alignment = CENTERED_ALIGNMENT;\n      }\n    }\n    switch (alignment) {\n      case START_ALIGNMENT:\n        return maxOffset;\n      case END_ALIGNMENT:\n        return minOffset;\n      case CENTERED_ALIGNMENT:\n        const middleOffset = Math.round(minOffset + (maxOffset - minOffset) / 2);\n        if (middleOffset < Math.ceil(width / 2)) {\n          return 0;\n        } else if (middleOffset > lastColumnOffset + Math.floor(width / 2)) {\n          return lastColumnOffset;\n        } else {\n          return middleOffset;\n        }\n      case AUTO_ALIGNMENT:\n      default:\n        if (scrollLeft >= minOffset && scrollLeft <= maxOffset) {\n          return scrollLeft;\n        } else if (minOffset > maxOffset) {\n          return minOffset;\n        } else if (scrollLeft < minOffset) {\n          return minOffset;\n        } else {\n          return maxOffset;\n        }\n    }\n  },\n  getRowOffset: ({ rowHeight, height, totalRow }, rowIndex, align, scrollTop, _, scrollBarWidth) => {\n    height = Number(height);\n    const lastRowOffset = Math.max(0, totalRow * rowHeight - height);\n    const maxOffset = Math.min(lastRowOffset, rowIndex * rowHeight);\n    const minOffset = Math.max(0, rowIndex * rowHeight - height + scrollBarWidth + rowHeight);\n    if (align === SMART_ALIGNMENT) {\n      if (scrollTop >= minOffset - height && scrollTop <= maxOffset + height) {\n        align = AUTO_ALIGNMENT;\n      } else {\n        align = CENTERED_ALIGNMENT;\n      }\n    }\n    switch (align) {\n      case START_ALIGNMENT:\n        return maxOffset;\n      case END_ALIGNMENT:\n        return minOffset;\n      case CENTERED_ALIGNMENT:\n        const middleOffset = Math.round(minOffset + (maxOffset - minOffset) / 2);\n        if (middleOffset < Math.ceil(height / 2)) {\n          return 0;\n        } else if (middleOffset > lastRowOffset + Math.floor(height / 2)) {\n          return lastRowOffset;\n        } else {\n          return middleOffset;\n        }\n      case AUTO_ALIGNMENT:\n      default:\n        if (scrollTop >= minOffset && scrollTop <= maxOffset) {\n          return scrollTop;\n        } else if (minOffset > maxOffset) {\n          return minOffset;\n        } else if (scrollTop < minOffset) {\n          return minOffset;\n        } else {\n          return maxOffset;\n        }\n    }\n  },\n  getColumnStartIndexForOffset: ({ columnWidth, totalColumn }, scrollLeft) => Math.max(0, Math.min(totalColumn - 1, Math.floor(scrollLeft / columnWidth))),\n  getColumnStopIndexForStartIndex: ({ columnWidth, totalColumn, width }, startIndex, scrollLeft) => {\n    const left = startIndex * columnWidth;\n    const visibleColumnsCount = Math.ceil((width + scrollLeft - left) / columnWidth);\n    return Math.max(0, Math.min(totalColumn - 1, startIndex + visibleColumnsCount - 1));\n  },\n  getRowStartIndexForOffset: ({ rowHeight, totalRow }, scrollTop) => Math.max(0, Math.min(totalRow - 1, Math.floor(scrollTop / rowHeight))),\n  getRowStopIndexForStartIndex: ({ rowHeight, totalRow, height }, startIndex, scrollTop) => {\n    const top = startIndex * rowHeight;\n    const numVisibleRows = Math.ceil((height + scrollTop - top) / rowHeight);\n    return Math.max(0, Math.min(totalRow - 1, startIndex + numVisibleRows - 1));\n  },\n  initCache: () => void 0,\n  clearCache: true,\n  validateProps: ({ columnWidth, rowHeight }) => {\n    if (process.env.NODE_ENV !== \"production\") {\n      if (!isNumber(columnWidth)) {\n        throwError(SCOPE$1, `\n          \"columnWidth\" must be passed as number,\n            instead ${typeof columnWidth} was given.\n        `);\n      }\n      if (!isNumber(rowHeight)) {\n        throwError(SCOPE$1, `\n          \"columnWidth\" must be passed as number,\n            instead ${typeof rowHeight} was given.\n        `);\n      }\n    }\n  }\n});\n\nconst { max, min, floor } = Math;\nconst SCOPE$2 = \"ElDynamicSizeGrid\";\nconst ACCESS_SIZER_KEY_MAP = {\n  column: \"columnWidth\",\n  row: \"rowHeight\"\n};\nconst ACCESS_LAST_VISITED_KEY_MAP = {\n  column: \"lastVisitedColumnIndex\",\n  row: \"lastVisitedRowIndex\"\n};\nconst getItemFromCache$1 = (props, index, gridCache, type) => {\n  const [cachedItems, sizer, lastVisited] = [\n    gridCache[type],\n    props[ACCESS_SIZER_KEY_MAP[type]],\n    gridCache[ACCESS_LAST_VISITED_KEY_MAP[type]]\n  ];\n  if (index > lastVisited) {\n    let offset = 0;\n    if (lastVisited >= 0) {\n      const item = cachedItems[lastVisited];\n      offset = item.offset + item.size;\n    }\n    for (let i = lastVisited + 1; i <= index; i++) {\n      const size = sizer(i);\n      cachedItems[i] = {\n        offset,\n        size\n      };\n      offset += size;\n    }\n    gridCache[ACCESS_LAST_VISITED_KEY_MAP[type]] = index;\n  }\n  return cachedItems[index];\n};\nconst bs$1 = (props, gridCache, low, high, offset, type) => {\n  while (low <= high) {\n    const mid = low + floor((high - low) / 2);\n    const currentOffset = getItemFromCache$1(props, mid, gridCache, type).offset;\n    if (currentOffset === offset) {\n      return mid;\n    } else if (currentOffset < offset) {\n      low = mid + 1;\n    } else {\n      high = mid - 1;\n    }\n  }\n  return max(0, low - 1);\n};\nconst es$1 = (props, gridCache, idx, offset, type) => {\n  const total = type === \"column\" ? props.totalColumn : props.totalRow;\n  let exponent = 1;\n  while (idx < total && getItemFromCache$1(props, idx, gridCache, type).offset < offset) {\n    idx += exponent;\n    exponent *= 2;\n  }\n  return bs$1(props, gridCache, floor(idx / 2), min(idx, total - 1), offset, type);\n};\nconst findItem$1 = (props, gridCache, offset, type) => {\n  const [cache, lastVisitedIndex] = [\n    gridCache[type],\n    gridCache[ACCESS_LAST_VISITED_KEY_MAP[type]]\n  ];\n  const lastVisitedItemOffset = lastVisitedIndex > 0 ? cache[lastVisitedIndex].offset : 0;\n  if (lastVisitedItemOffset >= offset) {\n    return bs$1(props, gridCache, 0, lastVisitedIndex, offset, type);\n  }\n  return es$1(props, gridCache, max(0, lastVisitedIndex), offset, type);\n};\nconst getEstimatedTotalHeight = ({ totalRow }, {\n  estimatedRowHeight,\n  lastVisitedRowIndex,\n  row\n}) => {\n  let sizeOfVisitedRows = 0;\n  if (lastVisitedRowIndex >= totalRow) {\n    lastVisitedRowIndex = totalRow - 1;\n  }\n  if (lastVisitedRowIndex >= 0) {\n    const item = row[lastVisitedRowIndex];\n    sizeOfVisitedRows = item.offset + item.size;\n  }\n  const unvisitedItems = totalRow - lastVisitedRowIndex - 1;\n  const sizeOfUnvisitedItems = unvisitedItems * estimatedRowHeight;\n  return sizeOfVisitedRows + sizeOfUnvisitedItems;\n};\nconst getEstimatedTotalWidth = ({\n  totalColumn\n}, {\n  column,\n  estimatedColumnWidth,\n  lastVisitedColumnIndex\n}) => {\n  let sizeOfVisitedColumns = 0;\n  if (lastVisitedColumnIndex > totalColumn) {\n    lastVisitedColumnIndex = totalColumn - 1;\n  }\n  if (lastVisitedColumnIndex >= 0) {\n    const item = column[lastVisitedColumnIndex];\n    sizeOfVisitedColumns = item.offset + item.size;\n  }\n  const unvisitedItems = totalColumn - lastVisitedColumnIndex - 1;\n  const sizeOfUnvisitedItems = unvisitedItems * estimatedColumnWidth;\n  return sizeOfVisitedColumns + sizeOfUnvisitedItems;\n};\nconst ACCESS_ESTIMATED_SIZE_KEY_MAP = {\n  column: getEstimatedTotalWidth,\n  row: getEstimatedTotalHeight\n};\nconst getOffset = (props, index, alignment, scrollOffset, cache, type, scrollBarWidth) => {\n  const [\n    size,\n    estimatedSizeAssociates\n  ] = [\n    type === \"row\" ? props.height : props.width,\n    ACCESS_ESTIMATED_SIZE_KEY_MAP[type]\n  ];\n  const item = getItemFromCache$1(props, index, cache, type);\n  const estimatedSize = estimatedSizeAssociates(props, cache);\n  const maxOffset = max(0, min(estimatedSize - size, item.offset));\n  const minOffset = max(0, item.offset - size + scrollBarWidth + item.size);\n  if (alignment === SMART_ALIGNMENT) {\n    if (scrollOffset >= minOffset - size && scrollOffset <= maxOffset + size) {\n      alignment = AUTO_ALIGNMENT;\n    } else {\n      alignment = CENTERED_ALIGNMENT;\n    }\n  }\n  switch (alignment) {\n    case START_ALIGNMENT: {\n      return maxOffset;\n    }\n    case END_ALIGNMENT: {\n      return minOffset;\n    }\n    case CENTERED_ALIGNMENT: {\n      return Math.round(minOffset + (maxOffset - minOffset) / 2);\n    }\n    case AUTO_ALIGNMENT:\n    default: {\n      if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {\n        return scrollOffset;\n      } else if (minOffset > maxOffset) {\n        return minOffset;\n      } else if (scrollOffset < minOffset) {\n        return minOffset;\n      } else {\n        return maxOffset;\n      }\n    }\n  }\n};\nconst FixedSizeGrid$1 = createGrid({\n  name: \"ElDynamicSizeGrid\",\n  getColumnPosition: (props, idx, cache) => {\n    const item = getItemFromCache$1(props, idx, cache, \"column\");\n    return [item.size, item.offset];\n  },\n  getRowPosition: (props, idx, cache) => {\n    const item = getItemFromCache$1(props, idx, cache, \"row\");\n    return [item.size, item.offset];\n  },\n  getColumnOffset: (props, columnIndex, alignment, scrollLeft, cache, scrollBarWidth) => getOffset(props, columnIndex, alignment, scrollLeft, cache, \"column\", scrollBarWidth),\n  getRowOffset: (props, rowIndex, alignment, scrollTop, cache, scrollBarWidth) => getOffset(props, rowIndex, alignment, scrollTop, cache, \"row\", scrollBarWidth),\n  getColumnStartIndexForOffset: (props, scrollLeft, cache) => findItem$1(props, cache, scrollLeft, \"column\"),\n  getColumnStopIndexForStartIndex: (props, startIndex, scrollLeft, cache) => {\n    const item = getItemFromCache$1(props, startIndex, cache, \"column\");\n    const maxOffset = scrollLeft + props.width;\n    let offset = item.offset + item.size;\n    let stopIndex = startIndex;\n    while (stopIndex < props.totalColumn - 1 && offset < maxOffset) {\n      stopIndex++;\n      offset += getItemFromCache$1(props, startIndex, cache, \"column\").size;\n    }\n    return stopIndex;\n  },\n  getEstimatedTotalHeight,\n  getEstimatedTotalWidth,\n  getRowStartIndexForOffset: (props, scrollTop, cache) => findItem$1(props, cache, scrollTop, \"row\"),\n  getRowStopIndexForStartIndex: (props, startIndex, scrollTop, cache) => {\n    const { totalRow, height } = props;\n    const item = getItemFromCache$1(props, startIndex, cache, \"row\");\n    const maxOffset = scrollTop + height;\n    let offset = item.size + item.offset;\n    let stopIndex = startIndex;\n    while (stopIndex < totalRow - 1 && offset < maxOffset) {\n      stopIndex++;\n      offset += getItemFromCache$1(props, stopIndex, cache, \"row\").size;\n    }\n    return stopIndex;\n  },\n  initCache: ({\n    estimatedColumnWidth = DEFAULT_DYNAMIC_LIST_ITEM_SIZE,\n    estimatedRowHeight = DEFAULT_DYNAMIC_LIST_ITEM_SIZE\n  }) => {\n    const cache = {\n      column: {},\n      estimatedColumnWidth,\n      estimatedRowHeight,\n      lastVisitedColumnIndex: -1,\n      lastVisitedRowIndex: -1,\n      row: {}\n    };\n    return cache;\n  },\n  clearCache: true,\n  validateProps: ({ columnWidth, rowHeight }) => {\n    if (process.env.NODE_ENV !== \"production\") {\n      if (!isFunction(columnWidth)) {\n        throwError(SCOPE$2, `\n          \"columnWidth\" must be passed as function,\n            instead ${typeof columnWidth} was given.\n        `);\n      }\n      if (!isFunction(rowHeight)) {\n        throwError(SCOPE$2, `\n          \"columnWidth\" must be passed as function,\n            instead ${typeof rowHeight} was given.\n        `);\n      }\n    }\n  }\n});\n\nexport { FixedSizeGrid$1 as DynamicSizeGrid, DynamicSizeList, FixedSizeGrid, FixedSizeList };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}