{"ast":null,"code":"export default function (n) {\n  return {\n    all: n = n || new Map(),\n    on: function (t, e) {\n      var i = n.get(t);\n      i && i.push(e) || n.set(t, [e]);\n    },\n    off: function (t, e) {\n      var i = n.get(t);\n      i && i.splice(i.indexOf(e) >>> 0, 1);\n    },\n    emit: function (t, e) {\n      (n.get(t) || []).slice().map(function (n) {\n        n(e);\n      }), (n.get(\"*\") || []).slice().map(function (n) {\n        n(t, e);\n      });\n    }\n  };\n}","map":{"version":3,"mappings":"yBAgC6BA;EAG5B,OAAO;IAKNA,KAPDA,IAAMA,KAAO,IAAIC,GAAJ,EAEN;IAaNC,cAAYC,CAAZD,EAA6BE,CAA7BF,EAA6BE;MAC5B,IAAMC,IAAWL,EAAIM,GAAJN,CAAQG,CAARH,CAAjB;MACcK,KAAYA,EAASE,IAATF,CAAcD,CAAdC,CAAZA,IAEbL,EAAIQ,GAAJR,CAAQG,CAARH,EAAc,CAACI,CAAD,CAAdJ,CAFaK;IAEED,CAjBX;IA2BNK,eAAaN,CAAbM,EAA8BL,CAA9BK,EAA8BL;MAC7B,IAAMC,IAAWL,EAAIM,GAAJN,CAAQG,CAARH,CAAjB;MACIK,KACHA,EAASK,MAATL,CAAgBA,EAASM,OAATN,CAAiBD,CAAjBC,MAA8B,CAA9CA,EAAiD,CAAjDA,CADGA;IAC8C,CA9B7C;IA4CNO,gBAAcT,CAAdS,EAA+BC,CAA/BD,EAA+BC;MAAAA,CAC5Bb,EAAIM,GAAJN,CAAQG,CAARH,KAAiB,EADWa,EACcC,KADdD,GACsBE,GADtBF,CAC0B,UAACT,CAAD,EAACA;QAAcA,EAAQS,CAART;MAAQS,CADjDA,GACiDA,CAC7Eb,EAAIM,GAAJN,CAAQ,GAARA,KAAgB,EAD6Da,EAC5BC,KAD4BD,GACpBE,GADoBF,CAChB,UAACT,CAAD,EAACA;QAAcA,EAAQD,CAARC,EAAcS,CAAdT;MAAcS,CADbA,CADjDA;IAE8DA;EA9CvF,CAAP;AA8C8FA","names":["all","Map","on","type","handler","handlers","get","push","set","off","splice","indexOf","emit","evt","slice","map"],"sources":["../src/index.ts"],"sourcesContent":["export type EventType = string | symbol;\n\n// An event handler can take an optional event argument\n// and should not return a value\nexport type Handler<T = any> = (event?: T) => void;\nexport type WildcardHandler = (type: EventType, event?: any) => void;\n\n// An array of all currently registered event handlers for a type\nexport type EventHandlerList = Array<Handler>;\nexport type WildCardEventHandlerList = Array<WildcardHandler>;\n\n// A map of event types and their corresponding event handlers.\nexport type EventHandlerMap = Map<EventType, EventHandlerList | WildCardEventHandlerList>;\n\nexport interface Emitter {\n\tall: EventHandlerMap;\n\n\ton<T = any>(type: EventType, handler: Handler<T>): void;\n\ton(type: '*', handler: WildcardHandler): void;\n\n\toff<T = any>(type: EventType, handler: Handler<T>): void;\n\toff(type: '*', handler: WildcardHandler): void;\n\n\temit<T = any>(type: EventType, event?: T): void;\n\temit(type: '*', event?: any): void;\n}\n\n/**\n * Mitt: Tiny (~200b) functional event emitter / pubsub.\n * @name mitt\n * @returns {Mitt}\n */\nexport default function mitt(all?: EventHandlerMap): Emitter {\n\tall = all || new Map();\n\n\treturn {\n\n\t\t/**\n\t\t * A Map of event names to registered handler functions.\n\t\t */\n\t\tall,\n\n\t\t/**\n\t\t * Register an event handler for the given type.\n\t\t * @param {string|symbol} type Type of event to listen for, or `\"*\"` for all events\n\t\t * @param {Function} handler Function to call in response to given event\n\t\t * @memberOf mitt\n\t\t */\n\t\ton<T = any>(type: EventType, handler: Handler<T>) {\n\t\t\tconst handlers = all.get(type);\n\t\t\tconst added = handlers && handlers.push(handler);\n\t\t\tif (!added) {\n\t\t\t\tall.set(type, [handler]);\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Remove an event handler for the given type.\n\t\t * @param {string|symbol} type Type of event to unregister `handler` from, or `\"*\"`\n\t\t * @param {Function} handler Handler function to remove\n\t\t * @memberOf mitt\n\t\t */\n\t\toff<T = any>(type: EventType, handler: Handler<T>) {\n\t\t\tconst handlers = all.get(type);\n\t\t\tif (handlers) {\n\t\t\t\thandlers.splice(handlers.indexOf(handler) >>> 0, 1);\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Invoke all handlers for the given type.\n\t\t * If present, `\"*\"` handlers are invoked after type-matched handlers.\n\t\t *\n\t\t * Note: Manually firing \"*\" handlers is not supported.\n\t\t *\n\t\t * @param {string|symbol} type The event type to invoke\n\t\t * @param {Any} [evt] Any value (object is recommended and powerful), passed to each handler\n\t\t * @memberOf mitt\n\t\t */\n\t\temit<T = any>(type: EventType, evt: T) {\n\t\t\t((all.get(type) || []) as EventHandlerList).slice().map((handler) => { handler(evt); });\n\t\t\t((all.get('*') || []) as WildCardEventHandlerList).slice().map((handler) => { handler(type, evt); });\n\t\t}\n\t};\n}\n"]},"metadata":{},"sourceType":"module"}